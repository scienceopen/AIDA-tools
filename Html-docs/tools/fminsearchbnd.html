<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of fminsearchbnd</title>
  <meta name="keywords" content="fminsearchbnd">
  <meta name="description" content="FMINSEARCHBND: FMINSEARCH, but with bound constraints by transformation">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html &copy; 2003 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../m2html.css">
</head>
<body>
<a name="_top"></a>
<!-- menu.html tools -->
<h1>fminsearchbnd
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>FMINSEARCHBND: FMINSEARCH, but with bound constraints by transformation</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>function [x,fval,exitflag,output] = fminsearchbnd(fun,x0,LB,UB,options,varargin) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre class="comment"> FMINSEARCHBND: FMINSEARCH, but with bound constraints by transformation
 usage: x=FMINSEARCHBND(fun,x0)
 usage: x=FMINSEARCHBND(fun,x0,LB)
 usage: x=FMINSEARCHBND(fun,x0,LB,UB)
 usage: x=FMINSEARCHBND(fun,x0,LB,UB,options)
 usage: x=FMINSEARCHBND(fun,x0,LB,UB,options,p1,p2,...)
 usage: [x,fval,exitflag,output]=FMINSEARCHBND(fun,x0,...)
 
 arguments:
  fun, x0, options - see the help for FMINSEARCH

  LB - lower bound vector or array, must be the same size as x0

       If no lower bounds exist for one of the variables, then
       supply -inf for that variable.

       If no lower bounds at all, then LB may be left empty.

       Variables may be fixed in value by setting the corresponding
       lower and upper bounds to exactly the same value.

  UB - upper bound vector or array, must be the same size as x0

       If no upper bounds exist for one of the variables, then
       supply +inf for that variable.

       If no upper bounds at all, then UB may be left empty.

       Variables may be fixed in value by setting the corresponding
       lower and upper bounds to exactly the same value.

 Notes:

  If options is supplied, then TolX will apply to the transformed
  variables. All other FMINSEARCH parameters should be unaffected.

  Variables which are constrained by both a lower and an upper
  bound will use a sin transformation. Those constrained by
  only a lower or an upper bound will use a quadratic
  transformation, and unconstrained variables will be left alone.

  Variables may be fixed by setting their respective bounds equal.
  In this case, the problem will be reduced in size for FMINSEARCH.

  The bounds are inclusive inequalities, which admit the
  boundary values themselves, but will not permit ANY function
  evaluations outside the bounds. These constraints are strictly
  followed.

  If your problem has an EXCLUSIVE (strict) constraint which will
  not admit evaluation at the bound itself, then you must provide
  a slightly offset bound. An example of this is a function which
  contains the log of one of its parameters. If you constrain the
  variable to have a lower bound of zero, then FMINSEARCHBND may
  try to evaluate the function exactly at zero.


 Example usage:
 rosen = @(x) (1-x(1)).^2 + 105*(x(2)-x(1).^2).^2;

 fminsearch(rosen,[3 3])     % unconstrained
 ans =
    1.0000    1.0000

 fminsearchbnd(rosen,[3 3],[2 2],[])     % constrained
 ans =
    2.0000    4.0000

 See test_main.m for other examples of use.


 See also: fminsearch, fminspleas


 Author: John D'Errico
 E-mail: woodchips@rochester.rr.com
 Release: 4
 Release date: 7/23/06</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../matlabicon.gif)">
</ul>
This function is called by:
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="../Aurora/runner4FlamingRays.html" class="code" title="function Ibest = runner4FlamingRays(indices2run,Keos,IstartGuesses,Ibestest,trmtr2Dto1D,A1Z,A2Z,E,Y,Z,OPS)">runner4FlamingRays</a>	runner4FlamingRays - Estimate electron precipitation variation with E and Y</li><li><a href="../Aurora/runner4FlamingRays0.html" class="code" title="">runner4FlamingRays0</a>	% Example script: how to estimate electron energies in flaming rays</li><li><a href="../Imgtools/img_optflow.html" class="code" title="function varargout = img_optflow(I1,I2,OPS)">img_optflow</a>	IMG_OPTFLOW - optical-flow displacements with intensity-scaling adjustment</li><li><a href="../Tomography/GACT_snippet.html" class="code" title="">GACT_snippet</a>	</li><li><a href="../Tomography/hh_tomo1234_New01.html" class="code" title="">hh_tomo1234_New01</a>	HH_TOMO1234_NEW01 - script for tomographing 2007 HIPAS-observations</li><li><a href="../Tomography/tomo_start_guessGACT.html" class="code" title="function [Vem,I2D] = tomo_start_guessGACT(stns,Energy,Ie2H,Xslice,Yslice,Zslice,M2Dto1D,U,V,I_cuts,iPeaks,X3D,Y3D,Z3D,ops)">tomo_start_guessGACT</a>	tomo_start_guessGACT - makes 3-D distribution of volume emission rates</li></ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="#_sub1" class="code">function stop = outfun_wrapper(x,varargin);</a></li><li><a href="#_sub2" class="code">function fval = intrafun(x,params)</a></li><li><a href="#_sub3" class="code">function xtrans = xtransform(x,params)</a></li></ul>
<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function [x,fval,exitflag,output] = fminsearchbnd(fun,x0,LB,UB,options,varargin)</a>
0002 <span class="comment">% FMINSEARCHBND: FMINSEARCH, but with bound constraints by transformation</span>
0003 <span class="comment">% usage: x=FMINSEARCHBND(fun,x0)</span>
0004 <span class="comment">% usage: x=FMINSEARCHBND(fun,x0,LB)</span>
0005 <span class="comment">% usage: x=FMINSEARCHBND(fun,x0,LB,UB)</span>
0006 <span class="comment">% usage: x=FMINSEARCHBND(fun,x0,LB,UB,options)</span>
0007 <span class="comment">% usage: x=FMINSEARCHBND(fun,x0,LB,UB,options,p1,p2,...)</span>
0008 <span class="comment">% usage: [x,fval,exitflag,output]=FMINSEARCHBND(fun,x0,...)</span>
0009 <span class="comment">%</span>
0010 <span class="comment">% arguments:</span>
0011 <span class="comment">%  fun, x0, options - see the help for FMINSEARCH</span>
0012 <span class="comment">%</span>
0013 <span class="comment">%  LB - lower bound vector or array, must be the same size as x0</span>
0014 <span class="comment">%</span>
0015 <span class="comment">%       If no lower bounds exist for one of the variables, then</span>
0016 <span class="comment">%       supply -inf for that variable.</span>
0017 <span class="comment">%</span>
0018 <span class="comment">%       If no lower bounds at all, then LB may be left empty.</span>
0019 <span class="comment">%</span>
0020 <span class="comment">%       Variables may be fixed in value by setting the corresponding</span>
0021 <span class="comment">%       lower and upper bounds to exactly the same value.</span>
0022 <span class="comment">%</span>
0023 <span class="comment">%  UB - upper bound vector or array, must be the same size as x0</span>
0024 <span class="comment">%</span>
0025 <span class="comment">%       If no upper bounds exist for one of the variables, then</span>
0026 <span class="comment">%       supply +inf for that variable.</span>
0027 <span class="comment">%</span>
0028 <span class="comment">%       If no upper bounds at all, then UB may be left empty.</span>
0029 <span class="comment">%</span>
0030 <span class="comment">%       Variables may be fixed in value by setting the corresponding</span>
0031 <span class="comment">%       lower and upper bounds to exactly the same value.</span>
0032 <span class="comment">%</span>
0033 <span class="comment">% Notes:</span>
0034 <span class="comment">%</span>
0035 <span class="comment">%  If options is supplied, then TolX will apply to the transformed</span>
0036 <span class="comment">%  variables. All other FMINSEARCH parameters should be unaffected.</span>
0037 <span class="comment">%</span>
0038 <span class="comment">%  Variables which are constrained by both a lower and an upper</span>
0039 <span class="comment">%  bound will use a sin transformation. Those constrained by</span>
0040 <span class="comment">%  only a lower or an upper bound will use a quadratic</span>
0041 <span class="comment">%  transformation, and unconstrained variables will be left alone.</span>
0042 <span class="comment">%</span>
0043 <span class="comment">%  Variables may be fixed by setting their respective bounds equal.</span>
0044 <span class="comment">%  In this case, the problem will be reduced in size for FMINSEARCH.</span>
0045 <span class="comment">%</span>
0046 <span class="comment">%  The bounds are inclusive inequalities, which admit the</span>
0047 <span class="comment">%  boundary values themselves, but will not permit ANY function</span>
0048 <span class="comment">%  evaluations outside the bounds. These constraints are strictly</span>
0049 <span class="comment">%  followed.</span>
0050 <span class="comment">%</span>
0051 <span class="comment">%  If your problem has an EXCLUSIVE (strict) constraint which will</span>
0052 <span class="comment">%  not admit evaluation at the bound itself, then you must provide</span>
0053 <span class="comment">%  a slightly offset bound. An example of this is a function which</span>
0054 <span class="comment">%  contains the log of one of its parameters. If you constrain the</span>
0055 <span class="comment">%  variable to have a lower bound of zero, then FMINSEARCHBND may</span>
0056 <span class="comment">%  try to evaluate the function exactly at zero.</span>
0057 <span class="comment">%</span>
0058 <span class="comment">%</span>
0059 <span class="comment">% Example usage:</span>
0060 <span class="comment">% rosen = @(x) (1-x(1)).^2 + 105*(x(2)-x(1).^2).^2;</span>
0061 <span class="comment">%</span>
0062 <span class="comment">% fminsearch(rosen,[3 3])     % unconstrained</span>
0063 <span class="comment">% ans =</span>
0064 <span class="comment">%    1.0000    1.0000</span>
0065 <span class="comment">%</span>
0066 <span class="comment">% fminsearchbnd(rosen,[3 3],[2 2],[])     % constrained</span>
0067 <span class="comment">% ans =</span>
0068 <span class="comment">%    2.0000    4.0000</span>
0069 <span class="comment">%</span>
0070 <span class="comment">% See test_main.m for other examples of use.</span>
0071 <span class="comment">%</span>
0072 <span class="comment">%</span>
0073 <span class="comment">% See also: fminsearch, fminspleas</span>
0074 <span class="comment">%</span>
0075 <span class="comment">%</span>
0076 <span class="comment">% Author: John D'Errico</span>
0077 <span class="comment">% E-mail: woodchips@rochester.rr.com</span>
0078 <span class="comment">% Release: 4</span>
0079 <span class="comment">% Release date: 7/23/06</span>
0080 
0081 <span class="comment">% size checks</span>
0082 xsize = size(x0);
0083 x0 = x0(:);
0084 n=length(x0);
0085 
0086 <span class="keyword">if</span> (nargin&lt;3) || isempty(LB)
0087   LB = repmat(-inf,n,1);
0088 <span class="keyword">else</span>
0089   LB = LB(:);
0090 <span class="keyword">end</span>
0091 <span class="keyword">if</span> (nargin&lt;4) || isempty(UB)
0092   UB = repmat(inf,n,1);
0093 <span class="keyword">else</span>
0094   UB = UB(:);
0095 <span class="keyword">end</span>
0096 
0097 <span class="keyword">if</span> (n~=length(LB)) || (n~=length(UB))
0098   error <span class="string">'x0 is incompatible in size with either LB or UB.'</span>
0099 <span class="keyword">end</span>
0100 
0101 <span class="comment">% set default options if necessary</span>
0102 <span class="keyword">if</span> (nargin&lt;5) || isempty(options)
0103   options = optimset(<span class="string">'fminsearch'</span>);
0104 <span class="keyword">end</span>
0105 
0106 <span class="comment">% stuff into a struct to pass around</span>
0107 params.args = varargin;
0108 params.LB = LB;
0109 params.UB = UB;
0110 params.fun = fun;
0111 params.n = n;
0112 <span class="comment">% note that the number of parameters may actually vary if</span>
0113 <span class="comment">% a user has chosen to fix one or more parameters</span>
0114 params.xsize = xsize;
0115 params.OutputFcn = [];
0116 
0117 <span class="comment">% 0 --&gt; unconstrained variable</span>
0118 <span class="comment">% 1 --&gt; lower bound only</span>
0119 <span class="comment">% 2 --&gt; upper bound only</span>
0120 <span class="comment">% 3 --&gt; dual finite bounds</span>
0121 <span class="comment">% 4 --&gt; fixed variable</span>
0122 params.BoundClass = zeros(n,1);
0123 <span class="keyword">for</span> i=1:n
0124   k = isfinite(LB(i)) + 2*isfinite(UB(i));
0125   params.BoundClass(i) = k;
0126   <span class="keyword">if</span> (k==3) &amp;&amp; (LB(i)==UB(i))
0127     params.BoundClass(i) = 4;
0128   <span class="keyword">end</span>
0129 <span class="keyword">end</span>
0130 
0131 <span class="comment">% transform starting values into their unconstrained</span>
0132 <span class="comment">% surrogates. Check for infeasible starting guesses.</span>
0133 x0u = x0;
0134 k=1;
0135 <span class="keyword">for</span> i = 1:n
0136   <span class="keyword">switch</span> params.BoundClass(i)
0137     <span class="keyword">case</span> 1
0138       <span class="comment">% lower bound only</span>
0139       <span class="keyword">if</span> x0(i)&lt;=LB(i)
0140         <span class="comment">% infeasible starting value. Use bound.</span>
0141         x0u(k) = 0;
0142       <span class="keyword">else</span>
0143         x0u(k) = sqrt(x0(i) - LB(i));
0144       <span class="keyword">end</span>
0145       
0146       <span class="comment">% increment k</span>
0147       k=k+1;
0148     <span class="keyword">case</span> 2
0149       <span class="comment">% upper bound only</span>
0150       <span class="keyword">if</span> x0(i)&gt;=UB(i)
0151         <span class="comment">% infeasible starting value. use bound.</span>
0152         x0u(k) = 0;
0153       <span class="keyword">else</span>
0154         x0u(k) = sqrt(UB(i) - x0(i));
0155       <span class="keyword">end</span>
0156       
0157       <span class="comment">% increment k</span>
0158       k=k+1;
0159     <span class="keyword">case</span> 3
0160       <span class="comment">% lower and upper bounds</span>
0161       <span class="keyword">if</span> x0(i)&lt;=LB(i)
0162         <span class="comment">% infeasible starting value</span>
0163         x0u(k) = -pi/2;
0164       <span class="keyword">elseif</span> x0(i)&gt;=UB(i)
0165         <span class="comment">% infeasible starting value</span>
0166         x0u(k) = pi/2;
0167       <span class="keyword">else</span>
0168         x0u(k) = 2*(x0(i) - LB(i))/(UB(i)-LB(i)) - 1;
0169         <span class="comment">% shift by 2*pi to avoid problems at zero in fminsearch</span>
0170         <span class="comment">% otherwise, the initial simplex is vanishingly small</span>
0171         x0u(k) = 2*pi+asin(max(-1,min(1,x0u(k))));
0172       <span class="keyword">end</span>
0173       
0174       <span class="comment">% increment k</span>
0175       k=k+1;
0176     <span class="keyword">case</span> 0
0177       <span class="comment">% unconstrained variable. x0u(i) is set.</span>
0178       x0u(k) = x0(i);
0179       
0180       <span class="comment">% increment k</span>
0181       k=k+1;
0182     <span class="keyword">case</span> 4
0183       <span class="comment">% fixed variable. drop it before fminsearch sees it.</span>
0184       <span class="comment">% k is not incremented for this variable.</span>
0185   <span class="keyword">end</span>
0186   
0187 <span class="keyword">end</span>
0188 <span class="comment">% if any of the unknowns were fixed, then we need to shorten</span>
0189 <span class="comment">% x0u now.</span>
0190 <span class="keyword">if</span> k&lt;=n
0191   x0u(k:n) = [];
0192 <span class="keyword">end</span>
0193 
0194 <span class="comment">% were all the variables fixed?</span>
0195 <span class="keyword">if</span> isempty(x0u)
0196   <span class="comment">% All variables were fixed. quit immediately, setting the</span>
0197   <span class="comment">% appropriate parameters, then return.</span>
0198   
0199   <span class="comment">% undo the variable transformations into the original space</span>
0200   x = <a href="#_sub3" class="code" title="subfunction xtrans = xtransform(x,params)">xtransform</a>(x0u,params);
0201   
0202   <span class="comment">% final reshape</span>
0203   x = reshape(x,xsize);
0204   
0205   <span class="comment">% stuff fval with the final value</span>
0206   fval = feval(params.fun,x,params.args{:});
0207   
0208   <span class="comment">% fminsearchbnd was not called</span>
0209   exitflag = 0;
0210   
0211   output.iterations = 0;
0212   output.funcCount = 1;
0213   output.algorithm = <span class="string">'fminsearch'</span>;
0214   output.message = <span class="string">'All variables were held fixed by the applied bounds'</span>;
0215   
0216   <span class="comment">% return with no call at all to fminsearch</span>
0217   <span class="keyword">return</span>
0218 <span class="keyword">end</span>
0219 
0220 <span class="comment">% Check for an outputfcn. If there is any, then substitute my</span>
0221 <span class="comment">% own wrapper function.</span>
0222 <span class="keyword">if</span> ~isempty(options.OutputFcn)
0223   params.OutputFcn = options.OutputFcn;
0224   options.OutputFcn = @<a href="#_sub1" class="code" title="subfunction stop = outfun_wrapper(x,varargin);">outfun_wrapper</a>;
0225 <span class="keyword">end</span>
0226 
0227 <span class="comment">% now we can call fminsearch, but with our own</span>
0228 <span class="comment">% intra-objective function.</span>
0229 [xu,fval,exitflag,output] = fminsearch(@<a href="#_sub2" class="code" title="subfunction fval = intrafun(x,params)">intrafun</a>,x0u,options,params);
0230 
0231 <span class="comment">% undo the variable transformations into the original space</span>
0232 x = <a href="#_sub3" class="code" title="subfunction xtrans = xtransform(x,params)">xtransform</a>(xu,params);
0233 
0234 <span class="comment">% final reshape to make sure the result has the proper shape</span>
0235 x = reshape(x,xsize);
0236 
0237 <span class="comment">% Use a nested function as the OutputFcn wrapper</span>
0238   <span class="keyword">function</span> stop = <a href="#_sub1" class="code" title="subfunction stop = outfun_wrapper(x,varargin);">outfun_wrapper</a>(x,varargin);
0239     <span class="comment">% we need to transform x first</span>
0240     xtrans = <a href="#_sub3" class="code" title="subfunction xtrans = xtransform(x,params)">xtransform</a>(x,params);
0241     
0242     <span class="comment">% then call the user supplied OutputFcn</span>
0243     stop = params.OutputFcn(xtrans,varargin{1:(end-1)});
0244     
0245   <span class="keyword">end</span>
0246 
0247 <span class="keyword">end</span> <span class="comment">% mainline end</span>
0248 
0249 <span class="comment">% ======================================</span>
0250 <span class="comment">% ========= begin subfunctions =========</span>
0251 <span class="comment">% ======================================</span>
0252 <a name="_sub1" href="#_subfunctions" class="code">function fval = intrafun(x,params)</a>
0253 <span class="comment">% transform variables, then call original function</span>
0254 
0255 <span class="comment">% transform</span>
0256 xtrans = <a href="#_sub3" class="code" title="subfunction xtrans = xtransform(x,params)">xtransform</a>(x,params);
0257 
0258 <span class="comment">% and call fun</span>
0259 fval = feval(params.fun,reshape(xtrans,params.xsize),params.args{:});
0260 
0261 <span class="keyword">end</span> <span class="comment">% sub function intrafun end</span>
0262 
0263 <span class="comment">% ======================================</span>
0264 <a name="_sub2" href="#_subfunctions" class="code">function xtrans = xtransform(x,params)</a>
0265 <span class="comment">% converts unconstrained variables into their original domains</span>
0266 
0267 xtrans = zeros(params.xsize);
0268 <span class="comment">% k allows some variables to be fixed, thus dropped from the</span>
0269 <span class="comment">% optimization.</span>
0270 k=1;
0271 <span class="keyword">for</span> i = 1:params.n
0272   <span class="keyword">switch</span> params.BoundClass(i)
0273     <span class="keyword">case</span> 1
0274       <span class="comment">% lower bound only</span>
0275       xtrans(i) = params.LB(i) + x(k).^2;
0276       
0277       k=k+1;
0278     <span class="keyword">case</span> 2
0279       <span class="comment">% upper bound only</span>
0280       xtrans(i) = params.UB(i) - x(k).^2;
0281       
0282       k=k+1;
0283     <span class="keyword">case</span> 3
0284       <span class="comment">% lower and upper bounds</span>
0285       xtrans(i) = (sin(x(k))+1)/2;
0286       xtrans(i) = xtrans(i)*(params.UB(i) - params.LB(i)) + params.LB(i);
0287       <span class="comment">% just in case of any floating point problems</span>
0288       xtrans(i) = max(params.LB(i),min(params.UB(i),xtrans(i)));
0289       
0290       k=k+1;
0291     <span class="keyword">case</span> 4
0292       <span class="comment">% fixed variable, bounds are equal, set it at either bound</span>
0293       xtrans(i) = params.LB(i);
0294     <span class="keyword">case</span> 0
0295       <span class="comment">% unconstrained variable.</span>
0296       xtrans(i) = x(k);
0297       
0298       k=k+1;
0299   <span class="keyword">end</span>
0300 <span class="keyword">end</span>
0301 
0302 <span class="keyword">end</span> <span class="comment">% sub function xtransform end</span>
0303 
0304 
0305 
0306 
0307</pre></div>
<hr><address>Generated on Sat 09-Feb-2013 12:20:36 by <strong>B.&nbsp;Gustavsson</strong> with <strong><a href="http://www.artefact.tk/software/matlab/m2html/" target="_parent">m2html</a></strong> &copy; 2003</address>
</body>
</html>