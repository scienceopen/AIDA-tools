<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of camera_model</title>
  <meta name="keywords" content="camera_model">
  <meta name="description" content="CAMERA_MODEL - determine the image coordinates of light from [az,ze]">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html &copy; 2003 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../m2html.css">
</head>
<body>
<a name="_top"></a>
<!-- menu.html Camera -->
<h1>camera_model
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>CAMERA_MODEL - determine the image coordinates of light from [az,ze]</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>function [u,w] = camera_model(az,ze,e1,e2,e3,optpar,optmod,imsiz) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre class="comment"> CAMERA_MODEL - determine the image coordinates of light from [az,ze]
 The point source is in the direction described by the azimuth and
 zenith angles AZ, ZE. E1, E2 and E3 are the rotated camera coordinate
 system. OPTPAR is the optical parameters, OPTMOD is the camera
 model, and IMSIZ is the image size.

 Calling:
  [u,w] = camera_model(az,ze,e1,e2,e3,optpar,optmod,imsiz)

 Input:
  az - azimuthal angle (radians) of lines of sight
  ze - zenith angle (radians) of lines of sight, should have same
       size as az.
  e1 - unit vector for horizontal image coordinates
  e2 - unit vector for vertical image coordinates
  e3 - unit vector for optical axis of camera
  OPTPAR - is a vector caracterising the optical
           transfer function, or an OPTPAR struct, with fields:
           sinzecosaz, sinzesinaz, u, v that define the horizontal
           components of a pixel l-o-s, and the pixel coordinates
           for the corresponding horizontal l-o-s components,
           respectively, and optionally a field rot (when used a
           vector with 3 Tait-Bryant rotaion angles)
  For OPTMOD 1-5 OPTPAR is an array where the fields have following
  meaning: 
  OPTPAR(1) is the horizontal focal widht (percent of the image size )
  OPTPAR(2) is the vertical focal width (percent of the image size )
  OPTPAR(6) is the horizontal displacement of the optical axis
  OPTPAR(7) is the vertical displacement of the optical axis
  OPTPAR(8) is a correction factor for deviations from a pin-hole
 camera-model. All parameters are relative to the image size.
  OPTMOD - is the optical model/transfer function to use:
           1 - f*tan(theta),
           2 - f*sin(alfa*theta),
           3 - f(alfa*theta + (1-alfa)*tan(theta))
           4 - f*theta
           5 - f*tan(alfa*theta)
          -1 - non-parametric, unrotated from zenith, with look-up
               tables,
          -2 - non-parametric, rotated from zenith, with look-up
               tables,
          11 - ASK camera model.
  OPTMOD is the camera-model-number.
  IMSIZ  - image size in pixels. 

 See also CAMERA_INV_MODEL</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="ASK_camera_model.html" class="code" title="function [x,y] = ASK_camera_model(az,el,a)">ASK_camera_model</a>	ASK_camera_model - the camera model for the ASK instrument.</li></ul>
This function is called by:
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="camera_mim_test.html" class="code" title="">camera_mim_test</a>	£££ Obsolete, perhaps, untested for such a long time it is</li><li><a href="project_directions.html" class="code" title="function [ua,wa] = project_directions(az,ze,optpar,optmod,imgsiz)">project_directions</a>	PROJECT_DIRECTIONS - calculates the image positions [UA,WA] from (AZ,ZE)</li><li><a href="project_point.html" class="code" title="function [u,v,l] = project_point(rs,optpar,r,cmtr,imsiz)">project_point</a>	PROJECT_POINT - project a point in space R down onto an image</li><li><a href="../Skymap/starplot.html" class="code" title="function [pstarsout] = starplot(pstars,SkMp)">starplot</a>	STARPLOT plots the skymap.</li><li><a href="../Spectral_cal/M6/star_int_search.html" class="code" title="function [idstarsok,stars_par] = star_int_search(img_in,optpar,optmode,plstars,OPTS)">star_int_search</a>	[idstarsok,stars_par] = star_int_search(img_in,optpar,optmode,pls</li><li><a href="../Spectral_cal/M7/star_int_search.html" class="code" title="function [idstarsok,stars_par] = star_int_search(img_in,optpar,optmode,plstars,OPTS)">star_int_search</a>	[idstarsok,stars_par] = star_int_search(img_in,optpar,optmode,plstars,OPTS)</li><li><a href="../Spectral_cal/star_int_model.html" class="code" title="function [varargout] = star_int_model(img_in,optpar,optmode,plstars,starpar,OPTS,BSTRNR)">star_int_model</a>	STAR_INT_MODEL - Model and plot of star</li><li><a href="../Spectral_cal/star_int_search_as.html" class="code" title="function [idstarsok,stars_par] = star_int_search_as(img_in,optpar,optmode,plstars,OPTS)">star_int_search_as</a>	STAR_INT_SEARCH identifies points in image with stars, make a parametrisation</li><li><a href="../Starcal/M6/autoidentify.html" class="code" title="function [idstarsok,stars_par] = autoidentify(SkMp)">autoidentify</a>	AUTOIDENTIFY - automatically identify all the stars of PLSTARS</li><li><a href="../Starcal/M7/autoidentify.html" class="code" title="function [idstarsok,stars_par] = autoidentify(SkMp)">autoidentify</a>	AUTOIDENTIFY - automatically identify all the stars of PLSTARS</li><li><a href="../Starcal/automat2.html" class="code" title="function [diff] = automat2(optpar,starteauw,mode,optpar2,lock_par,imsiz)">automat2</a>	AUTOMAT2 - total square of deviation between image and catalog position stars</li><li><a href="../Starcal/automat4.html" class="code" title="function [diff] = automat4(sp,starteauw,optmod,sp2,lock_par, imsiz)">automat4</a>	AUTOMAT4 - give sum tanh(dr)^2 between the image and catalog position of star</li><li><a href="../Starcal/findneareststarxy.html" class="code" title="function [staz,stze,stind,stmagn] = findneareststarxy(x0,y0,SkMp)">findneareststarxy</a>	FINDNEARESTSTARXY - find the star among PSTARS closest to X0, Y0</li><li><a href="../Starcal/remove_neareststarxy.html" class="code" title="function [staz,stze,stind,stmagn] = remove_neareststarxy(x0,y0,SkMp)">remove_neareststarxy</a>	remove_neareststarxy - remove the star among PSTARS closest to X0, Y0</li><li><a href="../Starcal/starplot2.html" class="code" title="function [pstarsout] = starplot2(pstars,SkMp)">starplot2</a>	STARPLOT2 plots the skymap.</li><li><a href="../Starcal/starsinimg.html" class="code" title="function [pstarsout,uk,wk] = starsinimg(pstars,optpar,optmod, imsiz)">starsinimg</a>	STARSINIMG is a function that plot the stars over the image.</li></ul>
<!-- crossreference -->


<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function [u,w] = camera_model(az,ze,e1,e2,e3,optpar,optmod,imsiz)</a>
0002 <span class="comment">% CAMERA_MODEL - determine the image coordinates of light from [az,ze]</span>
0003 <span class="comment">% The point source is in the direction described by the azimuth and</span>
0004 <span class="comment">% zenith angles AZ, ZE. E1, E2 and E3 are the rotated camera coordinate</span>
0005 <span class="comment">% system. OPTPAR is the optical parameters, OPTMOD is the camera</span>
0006 <span class="comment">% model, and IMSIZ is the image size.</span>
0007 <span class="comment">%</span>
0008 <span class="comment">% Calling:</span>
0009 <span class="comment">%  [u,w] = camera_model(az,ze,e1,e2,e3,optpar,optmod,imsiz)</span>
0010 <span class="comment">%</span>
0011 <span class="comment">% Input:</span>
0012 <span class="comment">%  az - azimuthal angle (radians) of lines of sight</span>
0013 <span class="comment">%  ze - zenith angle (radians) of lines of sight, should have same</span>
0014 <span class="comment">%       size as az.</span>
0015 <span class="comment">%  e1 - unit vector for horizontal image coordinates</span>
0016 <span class="comment">%  e2 - unit vector for vertical image coordinates</span>
0017 <span class="comment">%  e3 - unit vector for optical axis of camera</span>
0018 <span class="comment">%  OPTPAR - is a vector caracterising the optical</span>
0019 <span class="comment">%           transfer function, or an OPTPAR struct, with fields:</span>
0020 <span class="comment">%           sinzecosaz, sinzesinaz, u, v that define the horizontal</span>
0021 <span class="comment">%           components of a pixel l-o-s, and the pixel coordinates</span>
0022 <span class="comment">%           for the corresponding horizontal l-o-s components,</span>
0023 <span class="comment">%           respectively, and optionally a field rot (when used a</span>
0024 <span class="comment">%           vector with 3 Tait-Bryant rotaion angles)</span>
0025 <span class="comment">%  For OPTMOD 1-5 OPTPAR is an array where the fields have following</span>
0026 <span class="comment">%  meaning:</span>
0027 <span class="comment">%  OPTPAR(1) is the horizontal focal widht (percent of the image size )</span>
0028 <span class="comment">%  OPTPAR(2) is the vertical focal width (percent of the image size )</span>
0029 <span class="comment">%  OPTPAR(6) is the horizontal displacement of the optical axis</span>
0030 <span class="comment">%  OPTPAR(7) is the vertical displacement of the optical axis</span>
0031 <span class="comment">%  OPTPAR(8) is a correction factor for deviations from a pin-hole</span>
0032 <span class="comment">% camera-model. All parameters are relative to the image size.</span>
0033 <span class="comment">%  OPTMOD - is the optical model/transfer function to use:</span>
0034 <span class="comment">%           1 - f*tan(theta),</span>
0035 <span class="comment">%           2 - f*sin(alfa*theta),</span>
0036 <span class="comment">%           3 - f(alfa*theta + (1-alfa)*tan(theta))</span>
0037 <span class="comment">%           4 - f*theta</span>
0038 <span class="comment">%           5 - f*tan(alfa*theta)</span>
0039 <span class="comment">%          -1 - non-parametric, unrotated from zenith, with look-up</span>
0040 <span class="comment">%               tables,</span>
0041 <span class="comment">%          -2 - non-parametric, rotated from zenith, with look-up</span>
0042 <span class="comment">%               tables,</span>
0043 <span class="comment">%          11 - ASK camera model.</span>
0044 <span class="comment">%  OPTMOD is the camera-model-number.</span>
0045 <span class="comment">%  IMSIZ  - image size in pixels.</span>
0046 <span class="comment">%</span>
0047 <span class="comment">% See also CAMERA_INV_MODEL</span>
0048 
0049 <span class="comment">%   Copyright � 2001-03-30 Bjorn Gustavsson, &lt;bjorn.gustavsson@irf.se&gt;</span>
0050 <span class="comment">%   This is free software, licensed under GNU GPL version 2 or later</span>
0051 
0052 
0053 
0054 <span class="keyword">if</span> nargin &gt;= 8
0055   <span class="comment">% Todo: Check if this should be swapped:</span>
0056   bx = imsiz(2);<span class="comment">%%% Possible bug! BG 20060919</span>
0057   by = imsiz(1);<span class="comment">%%% Possible bug!</span>
0058 <span class="keyword">else</span>
0059   
0060   disp(<span class="string">'Calling: camera_model without ''imsiz'' argument this is _OBSOLETE_ and will no longer be supported'</span>)
0061   disp(<span class="string">'Here is where it happened:'</span>)
0062   dbstack
0063   
0064 <span class="keyword">end</span>
0065 
0066 
0067 <span class="keyword">if</span> ( optmod == 7 || optmod == -1 || optmod == 8 | optmod ==-2 )
0068 
0069   es1 = sin(ze).*sin(az);
0070   es2 = sin(ze).*cos(az);
0071   es3 = cos(ze);
0072   <span class="comment">% Projection of l-o-s vector in direction [az,ze] onto e1</span>
0073   dot_e_e1 = es1*e1(1) + es2*e1(2) + es3*e1(3);
0074   <span class="comment">% Projection of l-o-s vector in direction [az,ze] onto e2</span>
0075   dot_e_e2 = es1*e2(1) + es2*e2(2) + es3*e2(3);
0076   <span class="comment">% ��� Projection of l-o-s vector in direction [az,ze] onto e3</span>
0077   <span class="comment">% ��� dot_e_e3 = es1*e3(1) + es2*e3(2) + es3*e3(3);</span>
0078   cosazsinze_i = linspace(-1,1,50); <span class="comment">% cos*sin aer begraensade till</span>
0079   sinazsinze_i = linspace(-1,1,50); <span class="comment">% intervallet [-1 1]</span>
0080   u = interp2(sinazsinze_i,cosazsinze_i,optpar.u,dot_e_e1,dot_e_e2);
0081   w = interp2(sinazsinze_i,cosazsinze_i,optpar.v,dot_e_e1,dot_e_e2);
0082   
0083 <span class="keyword">elseif</span> 0 &amp; (optmod == 7 || optmod == -1)
0084   
0085   <span class="comment">% Non-parametric surfaces approximations applied. Full</span>
0086   <span class="comment">% interpolation-lookup table implementation. Used for asymmetric</span>
0087   <span class="comment">% (off-centered) mirror imaging and other assymetric</span>
0088   <span class="comment">% imaging set ups.</span>
0089    cosazsinze_i = linspace(-1,1,50); <span class="comment">% cos*sin aer begraensade till</span>
0090    sinazsinze_i = linspace(-1,1,50); <span class="comment">% intervallet [-1 1]</span>
0091    sinzecosaz = sin(ze).*cos(az);
0092    sinzesinaz = sin(ze).*sin(az);
0093    u = interp2(cosazsinze_i,sinazsinze_i,optpar.u,sinzecosaz,sinzesinaz);
0094    w = interp2(cosazsinze_i,sinazsinze_i,optpar.v,sinzecosaz,sinzesinaz);
0095    
0096 <span class="keyword">elseif</span> 0 &amp; ( optmod == 8 || optmod == -2)
0097   
0098   <span class="comment">% Non-parametric surfaces approximations applied. Full</span>
0099   <span class="comment">% interpolation-lookup table implementation. Used for asymmetric</span>
0100   <span class="comment">% (off-centered) mirror imaging and other assymetric</span>
0101   <span class="comment">% imaging set ups. This variant differs in that it uses the rotations.</span>
0102   
0103   sinze = sin(ze);
0104   es1 = sinze.*sin(az);
0105   es2 = sinze.*cos(az);
0106   es3 = cos(ze);
0107   
0108   <span class="comment">% Projection of unit vector in direction [az,ze] onto e1</span>
0109   sese1 = es1*e1(1) + es2*e1(2) + es3*e1(3);
0110   
0111   <span class="comment">% Projection of unit vector in direction [az,ze] onto e2</span>
0112   sese2 = es1*e2(1) + es2*e2(2) + es3*e2(3);
0113   
0114   cosazsinze_i = linspace(-1,1,50); <span class="comment">% cos*sin aer begraensade till</span>
0115   sinazsinze_i = linspace(-1,1,50); <span class="comment">% intervallet [-1 1]</span>
0116   u = interp2(cosazsinze_i,sinazsinze_i,optpar.u,sese1,sese2);
0117   w = interp2(cosazsinze_i,sinazsinze_i,optpar.v,sese1,sese2);
0118 
0119 <span class="keyword">elseif</span> optmod == -3
0120   
0121   es1 = sin(ze).*sin(az);
0122   es2 = sin(ze).*cos(az);
0123   es3 = cos(ze);
0124   <span class="comment">% Projection of l-o-s vector in direction [az,ze] onto e1</span>
0125   dot_e_e1 = es1*e1(1) + es2*e1(2) + es3*e1(3);
0126   <span class="comment">% Projection of l-o-s vector in direction [az,ze] onto e2</span>
0127   dot_e_e2 = es1*e2(1) + es2*e2(2) + es3*e2(3);
0128   <span class="comment">% ��� Projection of l-o-s vector in direction [az,ze] onto e3</span>
0129   <span class="comment">% ��� dot_e_e3 = es1*e3(1) + es2*e3(2) + es3*e3(3);</span>
0130   
0131   
0132   <span class="comment">% ��� cosazsinze_i = linspace(-1,1,50); % cos*sin aer begraensade till</span>
0133   <span class="comment">% ��� sinazsinze_i = linspace(-1,1,50); % intervallet [-1 1]</span>
0134   u = griddata(sin(optpar.az(:)).*sin(optpar.ze(:)),<span class="keyword">...</span>
0135                cos(optpar.az(:)).*sin(optpar.ze(:)),<span class="keyword">...</span>
0136                optpar.u(:),<span class="keyword">...</span>
0137                dot_e_e1,dot_e_e2);
0138   w = griddata(sin(optpar.az(:)).*sin(optpar.ze(:)),<span class="keyword">...</span>
0139                cos(optpar.az(:)).*sin(optpar.ze(:)),<span class="keyword">...</span>
0140                optpar.v(:),<span class="keyword">...</span>
0141                dot_e_e1,dot_e_e2);
0142   
0143 <span class="keyword">else</span>
0144   
0145   f1 = optpar(1);
0146   f2 = optpar(2);
0147   dx = optpar(6);
0148   dy = optpar(7);
0149   alfa = optpar(8);
0150   
0151   sinze = sin(ze);
0152   es1 = sinze.*sin(az);
0153   es2 = sinze.*cos(az);
0154   es3 = cos(ze);
0155   
0156   <span class="comment">% Projection of unit vector in direction [az,ze] onto e1</span>
0157   sese1 = es1*e1(1) + es2*e1(2) + es3*e1(3);
0158   
0159   <span class="comment">% Projection of unit vector in direction [az,ze] onto e2</span>
0160   sese2 = es1*e2(1) + es2*e2(2) + es3*e2(3);
0161   
0162   <span class="comment">% Projection of unit vector in direction [az,ze] onto e3</span>
0163   sese3 = es1*e3(1) + es2*e3(2) + es3*e3(3);
0164   
0165   <span class="keyword">switch</span> optmod
0166    <span class="keyword">case</span> 4
0167     <span class="comment">% ( u^2 + w^2 )^1/2 = f*taeta^alfa</span>
0168     <span class="comment">%## For pixel field-of-view to be finite alfa has to be 1.</span>
0169     
0170     <span class="comment">% thetas</span>
0171     atan_sese1sese2 = abs( atan(((sese1).^2+(sese2).^2).^.5./(sese3)) );
0172     <span class="comment">% For check-for-divide-by-zero</span>
0173     sese1_p_sese2 = ((sese1).^2+(sese2).^2).^.5;
0174     u2 = f1*(sese1)./sese1_p_sese2.*atan_sese1sese2.^alfa;
0175     w2 = f2*(sese2)./sese1_p_sese2.*atan_sese1sese2.^alfa;
0176     <span class="comment">% Check for divide-by-zero</span>
0177     u2(sese1_p_sese2 == 0 ) = 0;
0178     w2(sese1_p_sese2 == 0 ) = 0;
0179     <span class="comment">% Shift to center of image frame</span>
0180     u = u2 + .5 +dx;
0181     w = w2 + .5 +dy;
0182     
0183    <span class="keyword">case</span> 3
0184     <span class="comment">% ( u^2 + w^2 )^1/2 = f(a*taeta + (1-a)*tan(taeta))</span>
0185     <span class="comment">% Second term</span>
0186     u1 = f1*(1-alfa)*(sese1)./(sese3);
0187     w1 = f2*(1-alfa)*(sese2)./(sese3);
0188     <span class="comment">% thetas</span>
0189     atan_sese1sese2 = atan(((sese1).^2+(sese2).^2).^.5./(sese3));
0190     <span class="comment">% For check-for-divide-by-zero</span>
0191     sese1_p_sese2 = ((sese1).^2+(sese2).^2).^.5;
0192     <span class="comment">% First term</span>
0193     u2 = f1*alfa*(sese1)./sese1_p_sese2.*atan_sese1sese2;
0194     w2 = f2*alfa*(sese2)./sese1_p_sese2.*atan_sese1sese2;
0195     <span class="comment">% Check for divide-by-zero</span>
0196     u2(sese1_p_sese2 == 0 ) = 0;
0197     w2(sese1_p_sese2 == 0 ) = 0;
0198     <span class="comment">% Shift to center of image frame</span>
0199     u = u1 + u2 + .5 +dx;
0200     w = w1 + w2 + .5 +dy;
0201     
0202    <span class="keyword">case</span> 2
0203     <span class="comment">% ( u^2 + w^2 )^1/2 = f*sin(alfa*taeta)</span>
0204     
0205     <span class="comment">% thetas</span>
0206     taeta = atan(((sese1).^2+(sese2).^2).^.5./(sese3));
0207     <span class="comment">% For check-for-divide-by-zero</span>
0208     sese1_p_sese2 = ((sese1).^2+(sese2).^2).^.5;
0209     
0210     u2 = f1*(sese1)./((sese1).^2+(sese2).^2).^.5.*sin(taeta*alfa);
0211     w2 = f2*(sese2)./((sese1).^2+(sese2).^2).^.5.*sin(taeta*alfa);
0212     <span class="comment">% Check for divide-by-zero</span>
0213     u2(sese1_p_sese2 == 0 ) = 0;
0214     w2(sese1_p_sese2 == 0 ) = 0;
0215     
0216     <span class="comment">% Shift to center of image frame</span>
0217     u = u2 + .5 +dx;
0218     w = w2 + .5 +dy;
0219     
0220    <span class="keyword">case</span> 5
0221     <span class="comment">% ( u^2 + w^2 )^1/2 = f*tan(alfa*taeta)</span>
0222     
0223     <span class="comment">% thetas</span>
0224     taeta = atan(((sese1).^2+(sese2).^2).^.5./(sese3));
0225     <span class="comment">% For check-for-divide-by-zero</span>
0226     sese1_p_sese2 = ((sese1).^2+(sese2).^2).^.5;
0227     
0228     u2 = f1*(sese1)./((sese1).^2+(sese2).^2).^.5.*tan(taeta*alfa);
0229     w2 = f2*(sese2)./((sese1).^2+(sese2).^2).^.5.*tan(taeta*alfa);
0230     <span class="comment">% Check for divide-by-zero</span>
0231     u2(sese1_p_sese2 == 0 ) = 0;
0232     w2(sese1_p_sese2 == 0 ) = 0;
0233     
0234     <span class="comment">% Shift to center of image frame</span>
0235     u = u2 + .5 +dx;
0236     w = w2 + .5 +dy;
0237     
0238     
0239    <span class="keyword">case</span> 1
0240     
0241     <span class="comment">% ( u^2 + w^2 )^1/2 = f*tan(taeta)</span>
0242     u1 = f1*(sese1)./(sese3);
0243     w1 = f2*(sese2)./(sese3);
0244     <span class="comment">% Check for divide-by-zero</span>
0245     u1(sese3 == 0 ) = 0;  <span class="comment">% Changed on 20110109, was:  u2(sese3 == 0 ) = 0;</span>
0246     w1(sese3 == 0 ) = 0;  <span class="comment">% Changed on 20110109, was:  w2(sese3 == 0 ) = 0;</span>
0247     <span class="comment">% Shift to center of image frame</span>
0248     u = u1 + .5 +dx;
0249     w = w1 + .5 +dy;
0250     
0251    <span class="keyword">case</span> 6
0252     <span class="comment">% New Kiruna allsky-camera</span>
0253     <span class="comment">% within +-1 pixel for zenit &lt; 65-70 degrees</span>
0254     taeta = atan(((sese1).^2+(sese2).^2).^.5./(sese3));
0255     coefs = [1053.5 -1.0125 15.28 -109.4 58.874];
0256     r_of_th = ( coefs(1)*taeta + <span class="keyword">...</span>
0257                 coefs(2)*taeta.^2 + <span class="keyword">...</span>
0258                 coefs(3)*taeta.^3 + <span class="keyword">...</span>
0259                 coefs(4)*taeta.^4 + <span class="keyword">...</span>
0260                 coefs(5)*taeta.^5 );
0261     u2 = f1*(sese1)./((sese1).^2+(sese2).^2).^.5.*r_of_th/bx;
0262     w2 = f2*(sese2)./((sese1).^2+(sese2).^2).^.5.*r_of_th/by;
0263     u2((sese1).^2+(sese2).^2 == 0 ) = 0;
0264     w2((sese1).^2+(sese2).^2 == 0 ) = 0;
0265     
0266     u = u2 + .5 +dx;
0267     w = w2 + .5 +dy;
0268     
0269    <span class="keyword">case</span> 9
0270     <span class="comment">% Koschs kamera, no rotations</span>
0271     zep = -0.111218+1.178282*(ze*180/pi)-0.017945*(ze*180/pi).^2 + 0.00043*(ze*180/pi).^3;
0272     u = 10.174/2*zep.*cos(az)+369;
0273     w = 9.569/2*zep.*sin(az)+250;
0274    <span class="keyword">case</span> 11
0275     <span class="comment">% ASK camera model</span>
0276     [x,y] = <a href="ASK_camera_model.html" class="code" title="function [x,y] = ASK_camera_model(az,el,a)">ASK_camera_model</a>(az,pi/2-ze,optpar);
0277     u = x/bx;
0278     w = y/by;
0279     
0280    <span class="keyword">otherwise</span>
0281     
0282     u = zeros(size(az));
0283     w = zeros(size(az));
0284     warning([<span class="string">'Trying to use unknown camera model: '</span>,num2str(optmod)])
0285     
0286   <span class="keyword">end</span>
0287   
0288 <span class="keyword">end</span>
0289 
0290 <span class="keyword">if</span> optmod ~= 6
0291   
0292   u = u*bx;
0293   w = w*by;
0294   
0295 <span class="keyword">end</span></pre></div>
<hr><address>Generated on Sat 09-Feb-2013 12:20:36 by <strong>B.&nbsp;Gustavsson</strong> with <strong><a href="http://www.artefact.tk/software/matlab/m2html/" target="_parent">m2html</a></strong> &copy; 2003</address>
</body>
</html>