<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of project_point</title>
  <meta name="keywords" content="project_point">
  <meta name="description" content="PROJECT_POINT - project a point in space R down onto an image">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html &copy; 2003 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../m2html.css">
</head>
<body>
<a name="_top"></a>
<!-- menu.html Camera -->
<h1>project_point
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>PROJECT_POINT - project a point in space R down onto an image</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>function [u,v,l] = project_point(rs,optpar,r,cmtr,imsiz) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre class="comment"> PROJECT_POINT - project a point in space R down onto an image
 point [U,V]. The imager is located in RS and the 
   optical transfer is caracterized by OPTPAR. CMTR is a
   correction matrix for the rotations (optional)

Calling:
 [u,v] = project_point(r_stn,optpar,r,cmtr,imsiz)
 
 Input:
  rs     - [1x3] (or [3x1]) array for camera position. 
  r      - [nx3] (or [3xn]) array of point coordinates.
  optpar - parameters for optical model focal widths, camera
           rotation angles, image coordinates (relative units) for
           projection point of optical axis, shape factor, optical
           model.
  cmtr   - additional rotation matrix
  imsiz  - size of image.

 See also <a href="camera_base.html" class="code" title="function [e1,e2,e3] = camera_base(alfa,beta,fi,order)">CAMERA_BASE</a>, <a href="camera_model.html" class="code" title="function [u,w] = camera_model(az,ze,e1,e2,e3,optpar,optmod,imsiz)">CAMERA_MODEL</a>, INV_PROJECT_POINT</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="camera_base.html" class="code" title="function [e1,e2,e3] = camera_base(alfa,beta,fi,order)">camera_base</a>	CAMERA_BASE - determine the coordinate system of the camera</li><li><a href="camera_model.html" class="code" title="function [u,w] = camera_model(az,ze,e1,e2,e3,optpar,optmod,imsiz)">camera_model</a>	CAMERA_MODEL - determine the image coordinates of light from [az,ze]</li></ul>
This function is called by:
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="../ALIS/AVOK/alis_overview.html" class="code" title="function [M,filters,Times,I_minmax] = alis_overview(files,POs,OPS)">alis_overview</a>	ALIS_OVERVIEW - Overviews of alis data, movie or image-mosaics</li><li><a href="../ASK/HSOFT/ASK_draw_fov.html" class="code" title="function [varargout] = ASK_draw_fov(imsiz1,optpar1,imsiz2,optpar2,r1,r2,alt,cmtr,varargin)">ASK_draw_fov</a>	ASK_DRAW_FOV - Draw one cameras field-of-view in another cameras f-o-v</li><li><a href="../ASK/HSOFT/ASK_draw_north.html" class="code" title="function ph = ASK_draw_north(optpar,imsiz,ArrowLength,Colour,ArrowWidth,Start_uv,EastOrNorthOrUp)">ASK_draw_north</a>	ASK_DRAW_NORTH -  Draws the north direction on an image, from the centre.</li><li><a href="../ASK/HSOFT/ASK_fanograms.html" class="code" title="function [Keos,time_V,u,v] = ASK_fanograms(Indices2do,Cams,shifts,e_fan,width,OPS)">ASK_fanograms</a>	ASK_FANOGRAMS - Produce keograms of a fan-beam-cut from an ASK image sequence</li><li><a href="../ASK/HSOFT/ASK_get_fieldline.html" class="code" title="function [u,v] = ASK_get_fieldline(x0,y0,z,az,el,optpar,imsiz,r_Camera,varargin)">ASK_get_fieldline</a>	ASK_GET_FIELDLINE - get magnetic field-line projection onto an image.</li><li><a href="../ASK/HSOFT/ASK_get_radar.html" class="code" title="function [u0,v0,r,u,v,dr] = ASK_get_radar(radar_site,az,el,dphi,optpar,imsiz,l,r_Camera,varargin)">ASK_get_radar</a>	ASK_GET_RADAR - get image coordinates of the radar beam.</li><li><a href="../ASK/HSOFT/ASK_plot_fieldline.html" class="code" title="function ph = ASK_plot_fieldline(x0,y0,z,az,el,optpar,imsiz,r_Camera,varargin)">ASK_plot_fieldline</a>	ASK_PLOT_FIELDLINE - plot magnetic field-line projection onto an image.</li><li><a href="auto_quicktriang.html" class="code" title="function [ZZ,CC,cc3d] = auto_quicktriang(img1,r1,optmod1,optp1,img2,r2,optmod2,optp2,X,Y,Z,blksz,cm1,cm2)">auto_quicktriang</a>	AUTO_QUICKTRIANG - Automatic triangulation of structured surfaces</li><li><a href="inv_project_img_surf.html" class="code" title="function [Im_proj] = inv_project_img_surf(img_in,r,optmod,optpar,Xs,Ys,Zs,cmtr)">inv_project_img_surf</a>	INV_PROJECT_IMG_SURF - map IMG_IN - onto an arbitrary surface</li><li><a href="project_llh2img.html" class="code" title="function [u,v,uG,vG,cG1,cG2] = project_llh2img(longlatalt,long0lat0alt0,optpar,imsiz,gridstyle)">project_llh2img</a>	PROJECT_LLH2IMG - project a point in space LONGLATALT down onto an image</li><li><a href="triangulate.html" class="code" title="function [xtr,ytr,ztr,tu1,tv1,tu2,tv2,minl] = triangulate(img1,r1,img2,r2,cm1,cm2,PO,Opts)">triangulate</a>	TRIANGULATE - stereoscopic triangulation from a pair of images</li><li><a href="../Imgtools/img_stack2fanogram.html" class="code" title="function [Keos,Uout,Vout] = img_stack2fanogram(Imstacks,varargin)">img_stack2fanogram</a>	img_stack2fanogram - make fan-keograms from  image stack.</li><li><a href="../Imgtools/imgs_keograms_r3.html" class="code" title="function [Keo,exptimes,Tstrs,filters] = imgs_keograms_r3(files,rs,r,optpar,PO)">imgs_keograms_r3</a>	imgs_keogram_r3 - make keogram of R3's projection in the image.</li><li><a href="../Imgtools/imgs_rgb_keograms_r3.html" class="code" title="function [Keo,exptimes,Tstrs,filters] = imgs_rgb_keograms_r3(files,rs,r,optpar,PO)">imgs_rgb_keograms_r3</a>	imgs_keogram_r3 - make keogram of R3's projection in the image.</li><li><a href="../Tomography/camera_set_up_sc.html" class="code" title="function [uv,d,l_cl,bfk,ds] = camera_set_up_sc(r,xi,yi,zi,optpar,robs,imgsize,nr_layers,cmtr,ds)">camera_set_up_sc</a>	CAMERA_SET_UP_SC - Calculates the projection matrix from 3-D simple cubic grid</li><li><a href="../Tomography/tomo_cal0.html" class="code" title="function [CalFactors,stns,calimgs] = tomo_cal0(stns,XfI,YfI,ZfI,OPS)">tomo_cal0</a>	tomo_cal - estimate calibration factor for fastprojection of 3D b-o-b</li><li><a href="../Tomography/tomo_setup4reduced2D.html" class="code" title="function [trmtrs,U,V,X,Y,Z] = tomo_setup4reduced2D(stns,OPS)">tomo_setup4reduced2D</a>	tomo_setup4reduced2D - Set up coordinates and projection matrices</li></ul>
<!-- crossreference -->


<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function [u,v,l] = project_point(rs,optpar,r,cmtr,imsiz)</a>
0002 <span class="comment">% PROJECT_POINT - project a point in space R down onto an image</span>
0003 <span class="comment">% point [U,V]. The imager is located in RS and the</span>
0004 <span class="comment">%   optical transfer is caracterized by OPTPAR. CMTR is a</span>
0005 <span class="comment">%   correction matrix for the rotations (optional)</span>
0006 <span class="comment">%</span>
0007 <span class="comment">%Calling:</span>
0008 <span class="comment">% [u,v] = project_point(r_stn,optpar,r,cmtr,imsiz)</span>
0009 <span class="comment">%</span>
0010 <span class="comment">% Input:</span>
0011 <span class="comment">%  rs     - [1x3] (or [3x1]) array for camera position.</span>
0012 <span class="comment">%  r      - [nx3] (or [3xn]) array of point coordinates.</span>
0013 <span class="comment">%  optpar - parameters for optical model focal widths, camera</span>
0014 <span class="comment">%           rotation angles, image coordinates (relative units) for</span>
0015 <span class="comment">%           projection point of optical axis, shape factor, optical</span>
0016 <span class="comment">%           model.</span>
0017 <span class="comment">%  cmtr   - additional rotation matrix</span>
0018 <span class="comment">%  imsiz  - size of image.</span>
0019 <span class="comment">%</span>
0020 <span class="comment">% See also CAMERA_BASE, CAMERA_MODEL, INV_PROJECT_POINT</span>
0021 
0022 <span class="comment">%   Copyright ï¿½ 20050110 Bjorn Gustavsson, &lt;bjorn.gustavsson@irf.se&gt;</span>
0023 <span class="comment">%   This is free software, licensed under GNU GPL version 2 or later</span>
0024 
0025 
0026 <span class="keyword">if</span> nargin &lt; 5 || isempty(imsiz)
0027   imsiz = [bx by];
0028 <span class="keyword">end</span>
0029 
0030 <span class="comment">% Defining the rotated coordinate system of the cameras.</span>
0031 <span class="keyword">if</span> isstruct(optpar)
0032   optmod = optpar.mod;
0033   <span class="keyword">if</span> isfield(optpar,<span class="string">'rot'</span>)
0034     [e1_1,e1_2,e1_3] = <a href="camera_base.html" class="code" title="function [e1,e2,e3] = camera_base(alfa,beta,fi,order)">camera_base</a>(optpar.rot(1),optpar.rot(2),optpar.rot(3));
0035   <span class="keyword">else</span>
0036     [e1_1,e1_2,e1_3] = <a href="camera_base.html" class="code" title="function [e1,e2,e3] = camera_base(alfa,beta,fi,order)">camera_base</a>(0,0,0);
0037   <span class="keyword">end</span>
0038 <span class="keyword">else</span>
0039   <span class="keyword">if</span> length(optpar) &gt; 9
0040     [e1_1,e1_2,e1_3] = <a href="camera_base.html" class="code" title="function [e1,e2,e3] = camera_base(alfa,beta,fi,order)">camera_base</a>(optpar(3),optpar(4),optpar(5),optpar(10));
0041   <span class="keyword">else</span>
0042     [e1_1,e1_2,e1_3] = <a href="camera_base.html" class="code" title="function [e1,e2,e3] = camera_base(alfa,beta,fi,order)">camera_base</a>(optpar(3),optpar(4),optpar(5));
0043   <span class="keyword">end</span>
0044   optmod = optpar(9);
0045 <span class="keyword">end</span>
0046 <span class="keyword">if</span> nargin &gt; 3 &amp; ~isempty(cmtr)
0047   e1_1 = cmtr*e1_1;
0048   e1_2 = cmtr*e1_2;
0049   e1_3 = cmtr*e1_3;
0050 <span class="keyword">end</span>  
0051 <span class="comment">% To define a baseline for a vertical plane trough 2 stations.</span>
0052 
0053 <span class="keyword">if</span> size(r,2)&gt;1
0054   
0055   r1tmp(1,:) = r(1,:)-rs(1);
0056   r1tmp(2,:) = r(2,:)-rs(2);
0057   r1tmp(3,:) = r(3,:)-rs(3);
0058   
0059   az1 = atan2(r1tmp(1,:),r1tmp(2,:));
0060   ze1 = atan((r1tmp(1,:).^2+r1tmp(2,:).^2).^.5./r1tmp(3,:));
0061   <span class="comment">%disp(ze1(1)*180/pi)</span>
0062 <span class="keyword">else</span>
0063   
0064   r1tmp(1) = r(1)-rs(1);
0065   r1tmp(2) = r(2)-rs(2);
0066   r1tmp(3) = r(3)-rs(3);
0067   
0068   az1 = atan2(r1tmp(1),r1tmp(2));
0069   ze1 = atan((r1tmp(1).^2+r1tmp(2).^2).^.5./r1tmp(3));
0070   
0071 <span class="keyword">end</span>
0072 
0073 [u,v] = <a href="camera_model.html" class="code" title="function [u,w] = camera_model(az,ze,e1,e2,e3,optpar,optmod,imsiz)">camera_model</a>(az1,ze1,e1_1,e1_2,e1_3,optpar,optmod,imsiz);
0074 <span class="keyword">if</span> ( nargout == 3 )
0075   
0076   l = ( r1tmp(1,:).^2 + r1tmp(2,:).^2 + r1tmp(3,:).^2).^.5;
0077   
0078 <span class="keyword">end</span></pre></div>
<hr><address>Generated on Sat 09-Feb-2013 12:20:36 by <strong>B.&nbsp;Gustavsson</strong> with <strong><a href="http://www.artefact.tk/software/matlab/m2html/" target="_parent">m2html</a></strong> &copy; 2003</address>
</body>
</html>