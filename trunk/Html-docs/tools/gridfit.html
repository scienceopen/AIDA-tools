<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of gridfit</title>
  <meta name="keywords" content="gridfit">
  <meta name="description" content="gridfit: estimates a surface on a 2d grid, based on scattered data">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html &copy; 2003 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../m2html.css">
</head>
<body>
<a name="_top"></a>
<!-- menu.html tools -->
<h1>gridfit
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>gridfit: estimates a surface on a 2d grid, based on scattered data</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>function [zgrid,xgrid,ygrid] = gridfit(x,y,z,xnodes,ynodes,varargin) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre class="comment"> gridfit: estimates a surface on a 2d grid, based on scattered data
          Replicates are allowed. All methods extrapolate to the grid
          boundaries. Gridfit uses a modified ridge estimator to
          generate the surface, where the bias is toward smoothness.

          Gridfit is not an interpolant. Its goal is a smooth surface
          that approximates your data, but allows you to control the
          amount of smoothing.

 usage #1: zgrid = gridfit(x,y,z,xnodes,ynodes);
 usage #2: [zgrid,xgrid,ygrid] = gridfit(x,y,z,xnodes,ynodes);
 usage #3: zgrid = gridfit(x,y,z,xnodes,ynodes,prop,val,prop,val,...);

 Arguments: (input)
  x,y,z - vectors of equal lengths, containing arbitrary scattered data
          The only constraint on x and y is they cannot ALL fall on a
          single line in the x-y plane. Replicate points will be treated
          in a least squares sense.

          ANY points containing a NaN are ignored in the estimation

  xnodes - vector defining the nodes in the grid in the independent
          variable (x). xnodes need not be equally spaced. xnodes
          must completely span the data. If they do not, then the
          'extend' property is applied, adjusting the first and last
          nodes to be extended as necessary. See below for a complete
          description of the 'extend' property.

          If xnodes is a scalar integer, then it specifies the number
          of equally spaced nodes between the min and max of the data.

  ynodes - vector defining the nodes in the grid in the independent
          variable (y). ynodes need not be equally spaced.

          If ynodes is a scalar integer, then it specifies the number
          of equally spaced nodes between the min and max of the data.

          Also see the extend property.

  Additional arguments follow in the form of property/value pairs.
  Valid properties are:
    'smoothness', 'interp', 'regularizer', 'solver', 'maxiter'
    'extend', 'tilesize', 'overlap'

  Any UNAMBIGUOUS shortening (even down to a single letter) is
  valid for property names. All properties have default values,
  chosen (I hope) to give a reasonable result out of the box.

   'smoothness' - scalar or vector of length 2 - determines the
          eventual smoothness of the estimated surface. A larger
          value here means the surface will be smoother. Smoothness
          must be a non-negative real number.

          If this parameter is a vector of length 2, then it defines
          the relative smoothing to be associated with the x and y
          variables. This allows the user to apply a different amount
          of smoothing in the x dimension compared to the y dimension.

          Note: the problem is normalized in advance so that a
          smoothness of 1 MAY generate reasonable results. If you
          find the result is too smooth, then use a smaller value
          for this parameter. Likewise, bumpy surfaces suggest use
          of a larger value. (Sometimes, use of an iterative solver
          with too small a limit on the maximum number of iterations
          will result in non-convergence.)

          DEFAULT: 1


   'interp' - character, denotes the interpolation scheme used
          to interpolate the data.

          DEFAULT: 'triangle'

          'bilinear' - use bilinear interpolation within the grid
                     (also known as tensor product linear interpolation)

          'triangle' - split each cell in the grid into a triangle,
                     then linear interpolation inside each triangle

          'nearest' - nearest neighbor interpolation. This will
                     rarely be a good choice, but I included it
                     as an option for completeness.


   'regularizer' - character flag, denotes the regularization
          paradignm to be used. There are currently three options.

          DEFAULT: 'gradient'

          'diffusion' or 'laplacian' - uses a finite difference
              approximation to the Laplacian operator (i.e, del^2).

              We can think of the surface as a plate, wherein the
              bending rigidity of the plate is specified by the user
              as a number relative to the importance of fidelity to
              the data. A stiffer plate will result in a smoother
              surface overall, but fit the data less well. I've
              modeled a simple plate using the Laplacian, del^2. (A
              projected enhancement is to do a better job with the
              plate equations.)

              We can also view the regularizer as a diffusion problem,
              where the relative thermal conductivity is supplied.
              Here interpolation is seen as a problem of finding the
              steady temperature profile in an object, given a set of
              points held at a fixed temperature. Extrapolation will
              be linear. Both paradigms are appropriate for a Laplacian
              regularizer.

          'gradient' - attempts to ensure the gradient is as smooth
              as possible everywhere. Its subtly different from the
              'diffusion' option, in that here the directional
              derivatives are biased to be smooth across cell
              boundaries in the grid.

              The gradient option uncouples the terms in the Laplacian.
              Think of it as two coupled PDEs instead of one PDE. Why
              are they different at all? The terms in the Laplacian
              can balance each other.

          'springs' - uses a spring model connecting nodes to each
              other, as well as connecting data points to the nodes
              in the grid. This choice will cause any extrapolation
              to be as constant as possible.

              Here the smoothing parameter is the relative stiffness
              of the springs connecting the nodes to each other compared
              to the stiffness of a spting connecting the lattice to
              each data point. Since all springs have a rest length
              (length at which the spring has zero potential energy)
              of zero, any extrapolation will be minimized.

          Note: The 'springs' regularizer tends to drag the surface
          towards the mean of all the data, so too large a smoothing
          parameter may be a problem.


   'solver' - character flag - denotes the solver used for the
          resulting linear system. Different solvers will have
          different solution times depending upon the specific
          problem to be solved. Up to a certain size grid, the
          direct \ solver will often be speedy, until memory
          swaps causes problems.

          What solver should you use? Problems with a significant
          amount of extrapolation should avoid lsqr. \ may be
          best numerically for small smoothnesss parameters and
          high extents of extrapolation.

          Large numbers of points will slow down the direct
          \, but when applied to the normal equations, \ can be
          quite fast. Since the equations generated by these
          methods will tend to be well conditioned, the normal
          equations are not a bad choice of method to use. Beware
          when a small smoothing parameter is used, since this will
          make the equations less well conditioned.

          DEFAULT: 'normal'

          '\' - uses matlab's backslash operator to solve the sparse
                     system. 'backslash' is an alternate name.

          'symmlq' - uses matlab's iterative symmlq solver

          'lsqr' - uses matlab's iterative lsqr solver

          'normal' - uses \ to solve the normal equations.


   'maxiter' - only applies to iterative solvers - defines the
          maximum number of iterations for an iterative solver

          DEFAULT: min(10000,length(xnodes)*length(ynodes))


   'extend' - character flag - controls whether the first and last
          nodes in each dimension are allowed to be adjusted to
          bound the data, and whether the user will be warned if
          this was deemed necessary to happen.

          DEFAULT: 'warning'

          'warning' - Adjust the first and/or last node in
                     x or y if the nodes do not FULLY contain
                     the data. Issue a warning message to this
                     effect, telling the amount of adjustment
                     applied.

          'never'  - Issue an error message when the nodes do
                     not absolutely contain the data.

          'always' - automatically adjust the first and last
                     nodes in each dimension if necessary.
                     No warning is given when this option is set.


   'tilesize' - grids which are simply too large to solve for
          in one single estimation step can be built as a set
          of tiles. For example, a 1000x1000 grid will require
          the estimation of 1e6 unknowns. This is likely to
          require more memory (and time) than you have available.
          But if your data is dense enough, then you can model
          it locally using smaller tiles of the grid.

          My recommendation for a reasonable tilesize is
          roughly 100 to 200. Tiles of this size take only
          a few seconds to solve normally, so the entire grid
          can be modeled in a finite amount of time. The minimum
          tilesize can never be less than 3, although even this
          size tile is so small as to be ridiculous.

          If your data is so sparse than some tiles contain
          insufficient data to model, then those tiles will
          be left as NaNs.

          DEFAULT: inf


   'overlap' - Tiles in a grid have some overlap, so they
          can minimize any problems along the edge of a tile.
          In this overlapped region, the grid is built using a
          bi-linear combination of the overlapping tiles.

          The overlap is specified as a fraction of the tile
          size, so an overlap of 0.20 means there will be a 20%
          overlap of successive tiles. I do allow a zero overlap,
          but it must be no more than 1/2.

          0 &lt;= overlap &lt;= 0.5

          Overlap is ignored if the tilesize is greater than the
          number of nodes in both directions.

          DEFAULT: 0.20


   'autoscale' - Some data may have widely different scales on
          the respective x and y axes. If this happens, then
          the regularization may experience difficulties. 
          
          autoscale = 'on' will cause gridfit to scale the x
          and y node intervals to a unit length. This should
          improve the regularization procedure. The scaling is
          purely internal. 

          autoscale = 'off' will disable automatic scaling

          DEFAULT: 'on'


 Arguments: (output)
  zgrid   - (nx,ny) array containing the fitted surface

  xgrid, ygrid - as returned by meshgrid(xnodes,ynodes)


 Speed considerations:
  Remember that gridfit must solve a LARGE system of linear
  equations. There will be as many unknowns as the total
  number of nodes in the final lattice. While these equations
  may be sparse, solving a system of 10000 equations may take
  a second or so. Very large problems may benefit from the
  iterative solvers or from tiling.


 Example usage:

  x = rand(100,1);
  y = rand(100,1);
  z = exp(x+2*y);
  xnodes = 0:.1:1;
  ynodes = 0:.1:1;

  g = gridfit(x,y,z,xnodes,ynodes);

 Note: this is equivalent to the following call:

  g = gridfit(x,y,z,xnodes,ynodes, ...
              'smooth',1, ...
              'interp','triangle', ...
              'solver','normal', ...
              'regularizer','gradient', ...
              'extend','warning', ...
              'tilesize',inf);


 Author: John D'Errico
 e-mail address: woodchips@rochester.rr.com
 Release: 2.0
 Release date: 5/23/06</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="gridfit.html" class="code" title="function [zgrid,xgrid,ygrid] = gridfit(x,y,z,xnodes,ynodes,varargin)">gridfit</a>	gridfit: estimates a surface on a 2d grid, based on scattered data</li></ul>
This function is called by:
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="../Imgtools/img_reg_bg_red.html" class="code" title="function [Iout,Ibg] = img_reg_bg_red(Iin,reg4bg,method,method_args)">img_reg_bg_red</a>	IMG_REG_BG_RED - removal of estimated background in image region</li><li><a href="../Starcal/M6/runopticsoptimization.html" class="code" title="function [optpar,SkMp] = runopticsoptimization(SkMp,OptF_struct,varargin)">runopticsoptimization</a>	RUNOPTICSOPTIMIZATION - does the fitting of optical paramameters</li><li><a href="../Starcal/M7/runopticsoptimization.html" class="code" title="function [optpar,SkMp] = runopticsoptimization(SkMp,OptF_struct,varargin)">runopticsoptimization</a>	RUNOPTICSOPTIMIZATION - does the fitting of optical paramameters</li><li><a href="gridfit.html" class="code" title="function [zgrid,xgrid,ygrid] = gridfit(x,y,z,xnodes,ynodes,varargin)">gridfit</a>	gridfit: estimates a surface on a 2d grid, based on scattered data</li></ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="#_sub1" class="code">function params=parse_pv_pairs(params,pv_pairs)</a></li><li><a href="#_sub2" class="code">function params = check_params(params)</a></li><li><a href="#_sub3" class="code">function zgrid=tiled_gridfit(x,y,z,xnodes,ynodes,params)</a></li></ul>
<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function [zgrid,xgrid,ygrid] = gridfit(x,y,z,xnodes,ynodes,varargin)</a>
0002 <span class="comment">% gridfit: estimates a surface on a 2d grid, based on scattered data</span>
0003 <span class="comment">%          Replicates are allowed. All methods extrapolate to the grid</span>
0004 <span class="comment">%          boundaries. Gridfit uses a modified ridge estimator to</span>
0005 <span class="comment">%          generate the surface, where the bias is toward smoothness.</span>
0006 <span class="comment">%</span>
0007 <span class="comment">%          Gridfit is not an interpolant. Its goal is a smooth surface</span>
0008 <span class="comment">%          that approximates your data, but allows you to control the</span>
0009 <span class="comment">%          amount of smoothing.</span>
0010 <span class="comment">%</span>
0011 <span class="comment">% usage #1: zgrid = gridfit(x,y,z,xnodes,ynodes);</span>
0012 <span class="comment">% usage #2: [zgrid,xgrid,ygrid] = gridfit(x,y,z,xnodes,ynodes);</span>
0013 <span class="comment">% usage #3: zgrid = gridfit(x,y,z,xnodes,ynodes,prop,val,prop,val,...);</span>
0014 <span class="comment">%</span>
0015 <span class="comment">% Arguments: (input)</span>
0016 <span class="comment">%  x,y,z - vectors of equal lengths, containing arbitrary scattered data</span>
0017 <span class="comment">%          The only constraint on x and y is they cannot ALL fall on a</span>
0018 <span class="comment">%          single line in the x-y plane. Replicate points will be treated</span>
0019 <span class="comment">%          in a least squares sense.</span>
0020 <span class="comment">%</span>
0021 <span class="comment">%          ANY points containing a NaN are ignored in the estimation</span>
0022 <span class="comment">%</span>
0023 <span class="comment">%  xnodes - vector defining the nodes in the grid in the independent</span>
0024 <span class="comment">%          variable (x). xnodes need not be equally spaced. xnodes</span>
0025 <span class="comment">%          must completely span the data. If they do not, then the</span>
0026 <span class="comment">%          'extend' property is applied, adjusting the first and last</span>
0027 <span class="comment">%          nodes to be extended as necessary. See below for a complete</span>
0028 <span class="comment">%          description of the 'extend' property.</span>
0029 <span class="comment">%</span>
0030 <span class="comment">%          If xnodes is a scalar integer, then it specifies the number</span>
0031 <span class="comment">%          of equally spaced nodes between the min and max of the data.</span>
0032 <span class="comment">%</span>
0033 <span class="comment">%  ynodes - vector defining the nodes in the grid in the independent</span>
0034 <span class="comment">%          variable (y). ynodes need not be equally spaced.</span>
0035 <span class="comment">%</span>
0036 <span class="comment">%          If ynodes is a scalar integer, then it specifies the number</span>
0037 <span class="comment">%          of equally spaced nodes between the min and max of the data.</span>
0038 <span class="comment">%</span>
0039 <span class="comment">%          Also see the extend property.</span>
0040 <span class="comment">%</span>
0041 <span class="comment">%  Additional arguments follow in the form of property/value pairs.</span>
0042 <span class="comment">%  Valid properties are:</span>
0043 <span class="comment">%    'smoothness', 'interp', 'regularizer', 'solver', 'maxiter'</span>
0044 <span class="comment">%    'extend', 'tilesize', 'overlap'</span>
0045 <span class="comment">%</span>
0046 <span class="comment">%  Any UNAMBIGUOUS shortening (even down to a single letter) is</span>
0047 <span class="comment">%  valid for property names. All properties have default values,</span>
0048 <span class="comment">%  chosen (I hope) to give a reasonable result out of the box.</span>
0049 <span class="comment">%</span>
0050 <span class="comment">%   'smoothness' - scalar or vector of length 2 - determines the</span>
0051 <span class="comment">%          eventual smoothness of the estimated surface. A larger</span>
0052 <span class="comment">%          value here means the surface will be smoother. Smoothness</span>
0053 <span class="comment">%          must be a non-negative real number.</span>
0054 <span class="comment">%</span>
0055 <span class="comment">%          If this parameter is a vector of length 2, then it defines</span>
0056 <span class="comment">%          the relative smoothing to be associated with the x and y</span>
0057 <span class="comment">%          variables. This allows the user to apply a different amount</span>
0058 <span class="comment">%          of smoothing in the x dimension compared to the y dimension.</span>
0059 <span class="comment">%</span>
0060 <span class="comment">%          Note: the problem is normalized in advance so that a</span>
0061 <span class="comment">%          smoothness of 1 MAY generate reasonable results. If you</span>
0062 <span class="comment">%          find the result is too smooth, then use a smaller value</span>
0063 <span class="comment">%          for this parameter. Likewise, bumpy surfaces suggest use</span>
0064 <span class="comment">%          of a larger value. (Sometimes, use of an iterative solver</span>
0065 <span class="comment">%          with too small a limit on the maximum number of iterations</span>
0066 <span class="comment">%          will result in non-convergence.)</span>
0067 <span class="comment">%</span>
0068 <span class="comment">%          DEFAULT: 1</span>
0069 <span class="comment">%</span>
0070 <span class="comment">%</span>
0071 <span class="comment">%   'interp' - character, denotes the interpolation scheme used</span>
0072 <span class="comment">%          to interpolate the data.</span>
0073 <span class="comment">%</span>
0074 <span class="comment">%          DEFAULT: 'triangle'</span>
0075 <span class="comment">%</span>
0076 <span class="comment">%          'bilinear' - use bilinear interpolation within the grid</span>
0077 <span class="comment">%                     (also known as tensor product linear interpolation)</span>
0078 <span class="comment">%</span>
0079 <span class="comment">%          'triangle' - split each cell in the grid into a triangle,</span>
0080 <span class="comment">%                     then linear interpolation inside each triangle</span>
0081 <span class="comment">%</span>
0082 <span class="comment">%          'nearest' - nearest neighbor interpolation. This will</span>
0083 <span class="comment">%                     rarely be a good choice, but I included it</span>
0084 <span class="comment">%                     as an option for completeness.</span>
0085 <span class="comment">%</span>
0086 <span class="comment">%</span>
0087 <span class="comment">%   'regularizer' - character flag, denotes the regularization</span>
0088 <span class="comment">%          paradignm to be used. There are currently three options.</span>
0089 <span class="comment">%</span>
0090 <span class="comment">%          DEFAULT: 'gradient'</span>
0091 <span class="comment">%</span>
0092 <span class="comment">%          'diffusion' or 'laplacian' - uses a finite difference</span>
0093 <span class="comment">%              approximation to the Laplacian operator (i.e, del^2).</span>
0094 <span class="comment">%</span>
0095 <span class="comment">%              We can think of the surface as a plate, wherein the</span>
0096 <span class="comment">%              bending rigidity of the plate is specified by the user</span>
0097 <span class="comment">%              as a number relative to the importance of fidelity to</span>
0098 <span class="comment">%              the data. A stiffer plate will result in a smoother</span>
0099 <span class="comment">%              surface overall, but fit the data less well. I've</span>
0100 <span class="comment">%              modeled a simple plate using the Laplacian, del^2. (A</span>
0101 <span class="comment">%              projected enhancement is to do a better job with the</span>
0102 <span class="comment">%              plate equations.)</span>
0103 <span class="comment">%</span>
0104 <span class="comment">%              We can also view the regularizer as a diffusion problem,</span>
0105 <span class="comment">%              where the relative thermal conductivity is supplied.</span>
0106 <span class="comment">%              Here interpolation is seen as a problem of finding the</span>
0107 <span class="comment">%              steady temperature profile in an object, given a set of</span>
0108 <span class="comment">%              points held at a fixed temperature. Extrapolation will</span>
0109 <span class="comment">%              be linear. Both paradigms are appropriate for a Laplacian</span>
0110 <span class="comment">%              regularizer.</span>
0111 <span class="comment">%</span>
0112 <span class="comment">%          'gradient' - attempts to ensure the gradient is as smooth</span>
0113 <span class="comment">%              as possible everywhere. Its subtly different from the</span>
0114 <span class="comment">%              'diffusion' option, in that here the directional</span>
0115 <span class="comment">%              derivatives are biased to be smooth across cell</span>
0116 <span class="comment">%              boundaries in the grid.</span>
0117 <span class="comment">%</span>
0118 <span class="comment">%              The gradient option uncouples the terms in the Laplacian.</span>
0119 <span class="comment">%              Think of it as two coupled PDEs instead of one PDE. Why</span>
0120 <span class="comment">%              are they different at all? The terms in the Laplacian</span>
0121 <span class="comment">%              can balance each other.</span>
0122 <span class="comment">%</span>
0123 <span class="comment">%          'springs' - uses a spring model connecting nodes to each</span>
0124 <span class="comment">%              other, as well as connecting data points to the nodes</span>
0125 <span class="comment">%              in the grid. This choice will cause any extrapolation</span>
0126 <span class="comment">%              to be as constant as possible.</span>
0127 <span class="comment">%</span>
0128 <span class="comment">%              Here the smoothing parameter is the relative stiffness</span>
0129 <span class="comment">%              of the springs connecting the nodes to each other compared</span>
0130 <span class="comment">%              to the stiffness of a spting connecting the lattice to</span>
0131 <span class="comment">%              each data point. Since all springs have a rest length</span>
0132 <span class="comment">%              (length at which the spring has zero potential energy)</span>
0133 <span class="comment">%              of zero, any extrapolation will be minimized.</span>
0134 <span class="comment">%</span>
0135 <span class="comment">%          Note: The 'springs' regularizer tends to drag the surface</span>
0136 <span class="comment">%          towards the mean of all the data, so too large a smoothing</span>
0137 <span class="comment">%          parameter may be a problem.</span>
0138 <span class="comment">%</span>
0139 <span class="comment">%</span>
0140 <span class="comment">%   'solver' - character flag - denotes the solver used for the</span>
0141 <span class="comment">%          resulting linear system. Different solvers will have</span>
0142 <span class="comment">%          different solution times depending upon the specific</span>
0143 <span class="comment">%          problem to be solved. Up to a certain size grid, the</span>
0144 <span class="comment">%          direct \ solver will often be speedy, until memory</span>
0145 <span class="comment">%          swaps causes problems.</span>
0146 <span class="comment">%</span>
0147 <span class="comment">%          What solver should you use? Problems with a significant</span>
0148 <span class="comment">%          amount of extrapolation should avoid lsqr. \ may be</span>
0149 <span class="comment">%          best numerically for small smoothnesss parameters and</span>
0150 <span class="comment">%          high extents of extrapolation.</span>
0151 <span class="comment">%</span>
0152 <span class="comment">%          Large numbers of points will slow down the direct</span>
0153 <span class="comment">%          \, but when applied to the normal equations, \ can be</span>
0154 <span class="comment">%          quite fast. Since the equations generated by these</span>
0155 <span class="comment">%          methods will tend to be well conditioned, the normal</span>
0156 <span class="comment">%          equations are not a bad choice of method to use. Beware</span>
0157 <span class="comment">%          when a small smoothing parameter is used, since this will</span>
0158 <span class="comment">%          make the equations less well conditioned.</span>
0159 <span class="comment">%</span>
0160 <span class="comment">%          DEFAULT: 'normal'</span>
0161 <span class="comment">%</span>
0162 <span class="comment">%          '\' - uses matlab's backslash operator to solve the sparse</span>
0163 <span class="comment">%                     system. 'backslash' is an alternate name.</span>
0164 <span class="comment">%</span>
0165 <span class="comment">%          'symmlq' - uses matlab's iterative symmlq solver</span>
0166 <span class="comment">%</span>
0167 <span class="comment">%          'lsqr' - uses matlab's iterative lsqr solver</span>
0168 <span class="comment">%</span>
0169 <span class="comment">%          'normal' - uses \ to solve the normal equations.</span>
0170 <span class="comment">%</span>
0171 <span class="comment">%</span>
0172 <span class="comment">%   'maxiter' - only applies to iterative solvers - defines the</span>
0173 <span class="comment">%          maximum number of iterations for an iterative solver</span>
0174 <span class="comment">%</span>
0175 <span class="comment">%          DEFAULT: min(10000,length(xnodes)*length(ynodes))</span>
0176 <span class="comment">%</span>
0177 <span class="comment">%</span>
0178 <span class="comment">%   'extend' - character flag - controls whether the first and last</span>
0179 <span class="comment">%          nodes in each dimension are allowed to be adjusted to</span>
0180 <span class="comment">%          bound the data, and whether the user will be warned if</span>
0181 <span class="comment">%          this was deemed necessary to happen.</span>
0182 <span class="comment">%</span>
0183 <span class="comment">%          DEFAULT: 'warning'</span>
0184 <span class="comment">%</span>
0185 <span class="comment">%          'warning' - Adjust the first and/or last node in</span>
0186 <span class="comment">%                     x or y if the nodes do not FULLY contain</span>
0187 <span class="comment">%                     the data. Issue a warning message to this</span>
0188 <span class="comment">%                     effect, telling the amount of adjustment</span>
0189 <span class="comment">%                     applied.</span>
0190 <span class="comment">%</span>
0191 <span class="comment">%          'never'  - Issue an error message when the nodes do</span>
0192 <span class="comment">%                     not absolutely contain the data.</span>
0193 <span class="comment">%</span>
0194 <span class="comment">%          'always' - automatically adjust the first and last</span>
0195 <span class="comment">%                     nodes in each dimension if necessary.</span>
0196 <span class="comment">%                     No warning is given when this option is set.</span>
0197 <span class="comment">%</span>
0198 <span class="comment">%</span>
0199 <span class="comment">%   'tilesize' - grids which are simply too large to solve for</span>
0200 <span class="comment">%          in one single estimation step can be built as a set</span>
0201 <span class="comment">%          of tiles. For example, a 1000x1000 grid will require</span>
0202 <span class="comment">%          the estimation of 1e6 unknowns. This is likely to</span>
0203 <span class="comment">%          require more memory (and time) than you have available.</span>
0204 <span class="comment">%          But if your data is dense enough, then you can model</span>
0205 <span class="comment">%          it locally using smaller tiles of the grid.</span>
0206 <span class="comment">%</span>
0207 <span class="comment">%          My recommendation for a reasonable tilesize is</span>
0208 <span class="comment">%          roughly 100 to 200. Tiles of this size take only</span>
0209 <span class="comment">%          a few seconds to solve normally, so the entire grid</span>
0210 <span class="comment">%          can be modeled in a finite amount of time. The minimum</span>
0211 <span class="comment">%          tilesize can never be less than 3, although even this</span>
0212 <span class="comment">%          size tile is so small as to be ridiculous.</span>
0213 <span class="comment">%</span>
0214 <span class="comment">%          If your data is so sparse than some tiles contain</span>
0215 <span class="comment">%          insufficient data to model, then those tiles will</span>
0216 <span class="comment">%          be left as NaNs.</span>
0217 <span class="comment">%</span>
0218 <span class="comment">%          DEFAULT: inf</span>
0219 <span class="comment">%</span>
0220 <span class="comment">%</span>
0221 <span class="comment">%   'overlap' - Tiles in a grid have some overlap, so they</span>
0222 <span class="comment">%          can minimize any problems along the edge of a tile.</span>
0223 <span class="comment">%          In this overlapped region, the grid is built using a</span>
0224 <span class="comment">%          bi-linear combination of the overlapping tiles.</span>
0225 <span class="comment">%</span>
0226 <span class="comment">%          The overlap is specified as a fraction of the tile</span>
0227 <span class="comment">%          size, so an overlap of 0.20 means there will be a 20%</span>
0228 <span class="comment">%          overlap of successive tiles. I do allow a zero overlap,</span>
0229 <span class="comment">%          but it must be no more than 1/2.</span>
0230 <span class="comment">%</span>
0231 <span class="comment">%          0 &lt;= overlap &lt;= 0.5</span>
0232 <span class="comment">%</span>
0233 <span class="comment">%          Overlap is ignored if the tilesize is greater than the</span>
0234 <span class="comment">%          number of nodes in both directions.</span>
0235 <span class="comment">%</span>
0236 <span class="comment">%          DEFAULT: 0.20</span>
0237 <span class="comment">%</span>
0238 <span class="comment">%</span>
0239 <span class="comment">%   'autoscale' - Some data may have widely different scales on</span>
0240 <span class="comment">%          the respective x and y axes. If this happens, then</span>
0241 <span class="comment">%          the regularization may experience difficulties.</span>
0242 <span class="comment">%</span>
0243 <span class="comment">%          autoscale = 'on' will cause gridfit to scale the x</span>
0244 <span class="comment">%          and y node intervals to a unit length. This should</span>
0245 <span class="comment">%          improve the regularization procedure. The scaling is</span>
0246 <span class="comment">%          purely internal.</span>
0247 <span class="comment">%</span>
0248 <span class="comment">%          autoscale = 'off' will disable automatic scaling</span>
0249 <span class="comment">%</span>
0250 <span class="comment">%          DEFAULT: 'on'</span>
0251 <span class="comment">%</span>
0252 <span class="comment">%</span>
0253 <span class="comment">% Arguments: (output)</span>
0254 <span class="comment">%  zgrid   - (nx,ny) array containing the fitted surface</span>
0255 <span class="comment">%</span>
0256 <span class="comment">%  xgrid, ygrid - as returned by meshgrid(xnodes,ynodes)</span>
0257 <span class="comment">%</span>
0258 <span class="comment">%</span>
0259 <span class="comment">% Speed considerations:</span>
0260 <span class="comment">%  Remember that gridfit must solve a LARGE system of linear</span>
0261 <span class="comment">%  equations. There will be as many unknowns as the total</span>
0262 <span class="comment">%  number of nodes in the final lattice. While these equations</span>
0263 <span class="comment">%  may be sparse, solving a system of 10000 equations may take</span>
0264 <span class="comment">%  a second or so. Very large problems may benefit from the</span>
0265 <span class="comment">%  iterative solvers or from tiling.</span>
0266 <span class="comment">%</span>
0267 <span class="comment">%</span>
0268 <span class="comment">% Example usage:</span>
0269 <span class="comment">%</span>
0270 <span class="comment">%  x = rand(100,1);</span>
0271 <span class="comment">%  y = rand(100,1);</span>
0272 <span class="comment">%  z = exp(x+2*y);</span>
0273 <span class="comment">%  xnodes = 0:.1:1;</span>
0274 <span class="comment">%  ynodes = 0:.1:1;</span>
0275 <span class="comment">%</span>
0276 <span class="comment">%  g = gridfit(x,y,z,xnodes,ynodes);</span>
0277 <span class="comment">%</span>
0278 <span class="comment">% Note: this is equivalent to the following call:</span>
0279 <span class="comment">%</span>
0280 <span class="comment">%  g = gridfit(x,y,z,xnodes,ynodes, ...</span>
0281 <span class="comment">%              'smooth',1, ...</span>
0282 <span class="comment">%              'interp','triangle', ...</span>
0283 <span class="comment">%              'solver','normal', ...</span>
0284 <span class="comment">%              'regularizer','gradient', ...</span>
0285 <span class="comment">%              'extend','warning', ...</span>
0286 <span class="comment">%              'tilesize',inf);</span>
0287 <span class="comment">%</span>
0288 <span class="comment">%</span>
0289 <span class="comment">% Author: John D'Errico</span>
0290 <span class="comment">% e-mail address: woodchips@rochester.rr.com</span>
0291 <span class="comment">% Release: 2.0</span>
0292 <span class="comment">% Release date: 5/23/06</span>
0293 
0294 <span class="comment">% set defaults</span>
0295 params.smoothness = 1;
0296 params.interp = <span class="string">'triangle'</span>;
0297 params.regularizer = <span class="string">'gradient'</span>;
0298 params.solver = <span class="string">'backslash'</span>;
0299 params.maxiter = [];
0300 params.extend = <span class="string">'warning'</span>;
0301 params.tilesize = inf;
0302 params.overlap = 0.20;
0303 params.mask = []; 
0304 params.autoscale = <span class="string">'on'</span>;
0305 params.xscale = 1;
0306 params.yscale = 1;
0307 
0308 <span class="comment">% was the params struct supplied?</span>
0309 <span class="keyword">if</span> ~isempty(varargin)
0310   <span class="keyword">if</span> isstruct(varargin{1})
0311     <span class="comment">% params is only supplied if its a call from tiled_gridfit</span>
0312     params = varargin{1};
0313     <span class="keyword">if</span> length(varargin)&gt;1
0314       <span class="comment">% check for any overrides</span>
0315       params = <a href="#_sub1" class="code" title="subfunction params=parse_pv_pairs(params,pv_pairs)">parse_pv_pairs</a>(params,varargin{2:end});
0316     <span class="keyword">end</span>
0317   <span class="keyword">else</span>
0318     <span class="comment">% check for any overrides of the defaults</span>
0319     params = <a href="#_sub1" class="code" title="subfunction params=parse_pv_pairs(params,pv_pairs)">parse_pv_pairs</a>(params,varargin);
0320 
0321   <span class="keyword">end</span>
0322 <span class="keyword">end</span>
0323 
0324 <span class="comment">% check the parameters for acceptability</span>
0325 params = <a href="#_sub2" class="code" title="subfunction params = check_params(params)">check_params</a>(params);
0326 
0327 <span class="comment">% ensure all of x,y,z,xnodes,ynodes are column vectors,</span>
0328 <span class="comment">% also drop any NaN data</span>
0329 x=x(:);
0330 y=y(:);
0331 z=z(:);
0332 k = isnan(x) | isnan(y) | isnan(z);
0333 <span class="keyword">if</span> any(k)
0334   x(k)=[];
0335   y(k)=[];
0336   z(k)=[];
0337 <span class="keyword">end</span>
0338 xmin = min(x);
0339 xmax = max(x);
0340 ymin = min(y);
0341 ymax = max(y);
0342 
0343 <span class="comment">% did they supply a scalar for the nodes?</span>
0344 <span class="keyword">if</span> length(xnodes)==1
0345   xnodes = linspace(xmin,xmax,xnodes)';
0346   xnodes(end) = xmax; <span class="comment">% make sure it hits the max</span>
0347 <span class="keyword">end</span>
0348 <span class="keyword">if</span> length(ynodes)==1
0349   ynodes = linspace(ymin,ymax,ynodes)';
0350   ynodes(end) = ymax; <span class="comment">% make sure it hits the max</span>
0351 <span class="keyword">end</span>
0352 
0353 xnodes=xnodes(:);
0354 ynodes=ynodes(:);
0355 dx = diff(xnodes);
0356 dy = diff(ynodes);
0357 nx = length(xnodes);
0358 ny = length(ynodes);
0359 ngrid = nx*ny;
0360 
0361 <span class="comment">% set the scaling if autoscale was on</span>
0362 <span class="keyword">if</span> strcmpi(params.autoscale,<span class="string">'on'</span>)
0363   params.xscale = mean(dx);
0364   params.yscale = mean(dy);
0365   params.autoscale = <span class="string">'off'</span>;
0366 <span class="keyword">end</span>
0367 
0368 <span class="comment">% check to see if any tiling is necessary</span>
0369 <span class="keyword">if</span> (params.tilesize &lt; max(nx,ny))
0370   <span class="comment">% split it into smaller tiles. compute zgrid and ygrid</span>
0371   <span class="comment">% at the very end if requested</span>
0372   zgrid = <a href="#_sub3" class="code" title="subfunction zgrid=tiled_gridfit(x,y,z,xnodes,ynodes,params)">tiled_gridfit</a>(x,y,z,xnodes,ynodes,params);
0373 <span class="keyword">else</span>
0374   <span class="comment">% its a single tile.</span>
0375   
0376   <span class="comment">% mask must be either an empty array, or a boolean</span>
0377   <span class="comment">% aray of the same size as the final grid.</span>
0378   nmask = size(params.mask);
0379   <span class="keyword">if</span> ~isempty(params.mask) &amp; ((nmask(2)~=nx) | (nmask(1)~=ny))
0380     <span class="keyword">if</span> ((nmask(2)==ny) | (nmask(1)==nx))
0381       error <span class="string">'Mask array is probably transposed from proper orientation.'</span>
0382     <span class="keyword">else</span>
0383       error <span class="string">'Mask array must be the same size as the final grid.'</span>
0384     <span class="keyword">end</span>
0385   <span class="keyword">end</span>
0386   <span class="keyword">if</span> ~isempty(params.mask)
0387     params.maskflag = 1;
0388   <span class="keyword">else</span>
0389     params.maskflag = 0;
0390   <span class="keyword">end</span>
0391 
0392   <span class="comment">% default for maxiter?</span>
0393   <span class="keyword">if</span> isempty(params.maxiter)
0394     params.maxiter = min(10000,nx*ny);
0395   <span class="keyword">end</span>
0396 
0397   <span class="comment">% check lengths of the data</span>
0398   n = length(x);
0399   <span class="keyword">if</span> (length(y)~=n) | (length(z)~=n)
0400     error <span class="string">'Data vectors are incompatible in size.'</span>
0401   <span class="keyword">end</span>
0402   <span class="keyword">if</span> n&lt;3
0403     error <span class="string">'Insufficient data for surface estimation.'</span>
0404   <span class="keyword">end</span>
0405 
0406   <span class="comment">% verify the nodes are distinct</span>
0407   <span class="keyword">if</span> any(diff(xnodes)&lt;=0) | any(diff(ynodes)&lt;=0)
0408     error <span class="string">'xnodes and ynodes must be monotone increasing'</span>
0409   <span class="keyword">end</span>
0410 
0411   <span class="comment">% do we need to tweak the first or last node in x or y?</span>
0412   <span class="keyword">if</span> xmin&lt;xnodes(1)
0413     <span class="keyword">switch</span> params.extend
0414       <span class="keyword">case</span> <span class="string">'always'</span>
0415         xnodes(1) = xmin;
0416       <span class="keyword">case</span> <span class="string">'warning'</span>
0417         warning(<span class="string">'GRIDFIT:extend'</span>,[<span class="string">'xnodes(1) was decreased by: '</span>,num2str(xnodes(1)-xmin),<span class="string">', new node = '</span>,num2str(xmin)])
0418         xnodes(1) = xmin;
0419       <span class="keyword">case</span> <span class="string">'never'</span>
0420         error([<span class="string">'Some x ('</span>,num2str(xmin),<span class="string">') falls below xnodes(1) by: '</span>,num2str(xnodes(1)-xmin)])
0421     <span class="keyword">end</span>
0422   <span class="keyword">end</span>
0423   <span class="keyword">if</span> xmax&gt;xnodes(end)
0424     <span class="keyword">switch</span> params.extend
0425       <span class="keyword">case</span> <span class="string">'always'</span>
0426         xnodes(end) = xmax;
0427       <span class="keyword">case</span> <span class="string">'warning'</span>
0428         warning(<span class="string">'GRIDFIT:extend'</span>,[<span class="string">'xnodes(end) was increased by: '</span>,num2str(xmax-xnodes(end)),<span class="string">', new node = '</span>,num2str(xmax)])
0429         xnodes(end) = xmax;
0430       <span class="keyword">case</span> <span class="string">'never'</span>
0431         error([<span class="string">'Some x ('</span>,num2str(xmax),<span class="string">') falls above xnodes(end) by: '</span>,num2str(xmax-xnodes(end))])
0432     <span class="keyword">end</span>
0433   <span class="keyword">end</span>
0434   <span class="keyword">if</span> ymin&lt;ynodes(1)
0435     <span class="keyword">switch</span> params.extend
0436       <span class="keyword">case</span> <span class="string">'always'</span>
0437         ynodes(1) = ymin;
0438       <span class="keyword">case</span> <span class="string">'warning'</span>
0439         warning(<span class="string">'GRIDFIT:extend'</span>,[<span class="string">'ynodes(1) was decreased by: '</span>,num2str(ynodes(1)-ymin),<span class="string">', new node = '</span>,num2str(ymin)])
0440         ynodes(1) = ymin;
0441       <span class="keyword">case</span> <span class="string">'never'</span>
0442         error([<span class="string">'Some y ('</span>,num2str(ymin),<span class="string">') falls below ynodes(1) by: '</span>,num2str(ynodes(1)-ymin)])
0443     <span class="keyword">end</span>
0444   <span class="keyword">end</span>
0445   <span class="keyword">if</span> ymax&gt;ynodes(end)
0446     <span class="keyword">switch</span> params.extend
0447       <span class="keyword">case</span> <span class="string">'always'</span>
0448         ynodes(end) = ymax;
0449       <span class="keyword">case</span> <span class="string">'warning'</span>
0450         warning(<span class="string">'GRIDFIT:extend'</span>,[<span class="string">'ynodes(end) was increased by: '</span>,num2str(ymax-ynodes(end)),<span class="string">', new node = '</span>,num2str(ymax)])
0451         ynodes(end) = ymax;
0452       <span class="keyword">case</span> <span class="string">'never'</span>
0453         error([<span class="string">'Some y ('</span>,num2str(ymax),<span class="string">') falls above ynodes(end) by: '</span>,num2str(ymax-ynodes(end))])
0454     <span class="keyword">end</span>
0455   <span class="keyword">end</span>
0456   
0457   <span class="comment">% determine which cell in the array each point lies in</span>
0458   [junk,indx] = histc(x,xnodes); <span class="comment">%#ok</span>
0459   [junk,indy] = histc(y,ynodes); <span class="comment">%#ok</span>
0460   <span class="comment">% any point falling at the last node is taken to be</span>
0461   <span class="comment">% inside the last cell in x or y.</span>
0462   k=(indx==nx);
0463   indx(k)=indx(k)-1;
0464   k=(indy==ny);
0465   indy(k)=indy(k)-1;
0466   ind = indy + ny*(indx-1);
0467   
0468   <span class="comment">% Do we have a mask to apply?</span>
0469   <span class="keyword">if</span> params.maskflag
0470     <span class="comment">% if we do, then we need to ensure that every</span>
0471     <span class="comment">% cell with at least one data point also has at</span>
0472     <span class="comment">% least all of its corners unmasked.</span>
0473     params.mask(ind) = 1;
0474     params.mask(ind+1) = 1;
0475     params.mask(ind+ny) = 1;
0476     params.mask(ind+ny+1) = 1;
0477   <span class="keyword">end</span>
0478   
0479   <span class="comment">% interpolation equations for each point</span>
0480   tx = min(1,max(0,(x - xnodes(indx))./dx(indx)));
0481   ty = min(1,max(0,(y - ynodes(indy))./dy(indy)));
0482   <span class="comment">% Future enhancement: add cubic interpolant</span>
0483   <span class="keyword">switch</span> params.interp
0484     <span class="keyword">case</span> <span class="string">'triangle'</span>
0485       <span class="comment">% linear interpolation inside each triangle</span>
0486       k = (tx &gt; ty);
0487       L = ones(n,1);
0488       L(k) = ny;
0489       
0490       t1 = min(tx,ty);
0491       t2 = max(tx,ty);
0492       A = sparse(repmat((1:n)',1,3),[ind,ind+ny+1,ind+L], <span class="keyword">...</span>
0493         [1-t2,t1,t2-t1],n,ngrid);
0494       
0495     <span class="keyword">case</span> <span class="string">'nearest'</span>
0496       <span class="comment">% nearest neighbor interpolation in a cell</span>
0497       k = round(1-ty) + round(1-tx)*ny;
0498       A = sparse((1:n)',ind+k,ones(n,1),n,ngrid);
0499       
0500     <span class="keyword">case</span> <span class="string">'bilinear'</span>
0501       <span class="comment">% bilinear interpolation in a cell</span>
0502       A = sparse(repmat((1:n)',1,4),[ind,ind+1,ind+ny,ind+ny+1], <span class="keyword">...</span>
0503         [(1-tx).*(1-ty), (1-tx).*ty, tx.*(1-ty), tx.*ty], <span class="keyword">...</span>
0504         n,ngrid);
0505       
0506   <span class="keyword">end</span>
0507   rhs = z;
0508   
0509   <span class="comment">% do we have relative smoothing parameters?</span>
0510   <span class="keyword">if</span> numel(params.smoothness) == 1
0511     <span class="comment">% it was scalar, so treat both dimensions equally</span>
0512     smoothparam = params.smoothness;
0513     xyRelativeStiffness = [1;1];
0514   <span class="keyword">else</span>
0515     <span class="comment">% It was a vector, so anisotropy reigns.</span>
0516     <span class="comment">% I've already checked that the vector was of length 2</span>
0517     smoothparam = sqrt(prod(params.smoothness));
0518     xyRelativeStiffness = params.smoothness(:)./smoothparam;
0519   <span class="keyword">end</span>
0520   
0521   <span class="comment">% Build regularizer. Add del^4 regularizer one day.</span>
0522   <span class="keyword">switch</span> params.regularizer
0523     <span class="keyword">case</span> <span class="string">'springs'</span>
0524       <span class="comment">% zero &quot;rest length&quot; springs</span>
0525       [i,j] = meshgrid(1:nx,1:(ny-1));
0526       ind = j(:) + ny*(i(:)-1);
0527       m = nx*(ny-1);
0528       stiffness = 1./(dy/params.yscale);
0529       Areg = sparse(repmat((1:m)',1,2),[ind,ind+1], <span class="keyword">...</span>
0530         xyRelativeStiffness(2)*stiffness(j(:))*[-1 1], <span class="keyword">...</span>
0531         m,ngrid);
0532       
0533       [i,j] = meshgrid(1:(nx-1),1:ny);
0534       ind = j(:) + ny*(i(:)-1);
0535       m = (nx-1)*ny;
0536       stiffness = 1./(dx/params.xscale);
0537       Areg = [Areg;sparse(repmat((1:m)',1,2),[ind,ind+ny], <span class="keyword">...</span>
0538         xyRelativeStiffness(1)*stiffness(i(:))*[-1 1],m,ngrid)];
0539       
0540       [i,j] = meshgrid(1:(nx-1),1:(ny-1));
0541       ind = j(:) + ny*(i(:)-1);
0542       m = (nx-1)*(ny-1);
0543       stiffness = 1./sqrt((dx(i(:))/params.xscale/xyRelativeStiffness(1)).^2 + <span class="keyword">...</span>
0544         (dy(j(:))/params.yscale/xyRelativeStiffness(2)).^2);
0545       
0546       Areg = [Areg;sparse(repmat((1:m)',1,2),[ind,ind+ny+1], <span class="keyword">...</span>
0547         stiffness*[-1 1],m,ngrid)];
0548       
0549       Areg = [Areg;sparse(repmat((1:m)',1,2),[ind+1,ind+ny], <span class="keyword">...</span>
0550         stiffness*[-1 1],m,ngrid)];
0551       
0552     <span class="keyword">case</span> {<span class="string">'diffusion'</span> <span class="string">'laplacian'</span>}
0553       <span class="comment">% thermal diffusion using Laplacian (del^2)</span>
0554       [i,j] = meshgrid(1:nx,2:(ny-1));
0555       ind = j(:) + ny*(i(:)-1);
0556       dy1 = dy(j(:)-1)/params.yscale;
0557       dy2 = dy(j(:))/params.yscale;
0558       
0559       Areg = sparse(repmat(ind,1,3),[ind-1,ind,ind+1], <span class="keyword">...</span>
0560         xyRelativeStiffness(2)*[-2./(dy1.*(dy1+dy2)), <span class="keyword">...</span>
0561         2./(dy1.*dy2), -2./(dy2.*(dy1+dy2))],ngrid,ngrid);
0562       
0563       [i,j] = meshgrid(2:(nx-1),1:ny);
0564       ind = j(:) + ny*(i(:)-1);
0565       dx1 = dx(i(:)-1)/params.xscale;
0566       dx2 = dx(i(:))/params.xscale;
0567       
0568       Areg = Areg + sparse(repmat(ind,1,3),[ind-ny,ind,ind+ny], <span class="keyword">...</span>
0569         xyRelativeStiffness(1)*[-2./(dx1.*(dx1+dx2)), <span class="keyword">...</span>
0570         2./(dx1.*dx2), -2./(dx2.*(dx1+dx2))],ngrid,ngrid);
0571       
0572     <span class="keyword">case</span> <span class="string">'gradient'</span>
0573       <span class="comment">% Subtly different from the Laplacian. A point for future</span>
0574       <span class="comment">% enhancement is to do it better for the triangle interpolation</span>
0575       <span class="comment">% case.</span>
0576       [i,j] = meshgrid(1:nx,2:(ny-1));
0577       ind = j(:) + ny*(i(:)-1);
0578       dy1 = dy(j(:)-1)/params.yscale;
0579       dy2 = dy(j(:))/params.yscale;
0580       
0581       Areg = sparse(repmat(ind,1,3),[ind-1,ind,ind+1], <span class="keyword">...</span>
0582         xyRelativeStiffness(2)*[-2./(dy1.*(dy1+dy2)), <span class="keyword">...</span>
0583         2./(dy1.*dy2), -2./(dy2.*(dy1+dy2))],ngrid,ngrid);
0584       
0585       [i,j] = meshgrid(2:(nx-1),1:ny);
0586       ind = j(:) + ny*(i(:)-1);
0587       dx1 = dx(i(:)-1)/params.xscale;
0588       dx2 = dx(i(:))/params.xscale;
0589       
0590       Areg = [Areg;sparse(repmat(ind,1,3),[ind-ny,ind,ind+ny], <span class="keyword">...</span>
0591         xyRelativeStiffness(1)*[-2./(dx1.*(dx1+dx2)), <span class="keyword">...</span>
0592         2./(dx1.*dx2), -2./(dx2.*(dx1+dx2))],ngrid,ngrid)];
0593       
0594   <span class="keyword">end</span>
0595   nreg = size(Areg,1);
0596   
0597   <span class="comment">% Append the regularizer to the interpolation equations,</span>
0598   <span class="comment">% scaling the problem first. Use the 1-norm for speed.</span>
0599   NA = norm(A,1);
0600   NR = norm(Areg,1);
0601   A = [A;Areg*(smoothparam*NA/NR)];
0602   rhs = [rhs;zeros(nreg,1)];
0603   <span class="comment">% do we have a mask to apply?</span>
0604   <span class="keyword">if</span> params.maskflag
0605     unmasked = find(params.mask);
0606   <span class="keyword">end</span>
0607   <span class="comment">% solve the full system, with regularizer attached</span>
0608   <span class="keyword">switch</span> params.solver
0609     <span class="keyword">case</span> {<span class="string">'\'</span> <span class="string">'backslash'</span>}
0610       <span class="keyword">if</span> params.maskflag
0611         <span class="comment">% there is a mask to use</span>
0612         zgrid=nan(ny,nx);
0613         zgrid(unmasked) = A(:,unmasked)\rhs;
0614       <span class="keyword">else</span>
0615         <span class="comment">% no mask</span>
0616         zgrid = reshape(A\rhs,ny,nx);
0617       <span class="keyword">end</span>
0618       
0619     <span class="keyword">case</span> <span class="string">'normal'</span>
0620       <span class="comment">% The normal equations, solved with \. Can be faster</span>
0621       <span class="comment">% for huge numbers of data points, but reasonably</span>
0622       <span class="comment">% sized grids. The regularizer makes A well conditioned</span>
0623       <span class="comment">% so the normal equations are not a terribly bad thing</span>
0624       <span class="comment">% here.</span>
0625       <span class="keyword">if</span> params.maskflag
0626         <span class="comment">% there is a mask to use</span>
0627         Aunmasked = A(:,unmasked);
0628         zgrid=nan(ny,nx);
0629         zgrid(unmasked) = (Aunmasked'*Aunmasked)\(Aunmasked'*rhs);
0630       <span class="keyword">else</span>
0631         zgrid = reshape((A'*A)\(A'*rhs),ny,nx);
0632       <span class="keyword">end</span>
0633       
0634     <span class="keyword">case</span> <span class="string">'symmlq'</span>
0635       <span class="comment">% iterative solver - symmlq - requires a symmetric matrix,</span>
0636       <span class="comment">% so use it to solve the normal equations. No preconditioner.</span>
0637       tol = abs(max(z)-min(z))*1.e-13;
0638       <span class="keyword">if</span> params.maskflag
0639         <span class="comment">% there is a mask to use</span>
0640         zgrid=nan(ny,nx);
0641         [zgrid(unmasked),flag] = symmlq(A(:,unmasked)'*A(:,unmasked), <span class="keyword">...</span>
0642           A(:,unmasked)'*rhs,tol,params.maxiter);
0643       <span class="keyword">else</span>
0644         [zgrid,flag] = symmlq(A'*A,A'*rhs,tol,params.maxiter);
0645         zgrid = reshape(zgrid,ny,nx);
0646       <span class="keyword">end</span>
0647       <span class="comment">% display a warning if convergence problems</span>
0648       <span class="keyword">switch</span> flag
0649         <span class="keyword">case</span> 0
0650           <span class="comment">% no problems with convergence</span>
0651         <span class="keyword">case</span> 1
0652           <span class="comment">% SYMMLQ iterated MAXIT times but did not converge.</span>
0653           warning(<span class="string">'GRIDFIT:solver'</span>,[<span class="string">'Symmlq performed '</span>,num2str(params.maxiter), <span class="keyword">...</span>
0654             <span class="string">' iterations but did not converge.'</span>])
0655         <span class="keyword">case</span> 3
0656           <span class="comment">% SYMMLQ stagnated, successive iterates were the same</span>
0657           warning(<span class="string">'GRIDFIT:solver'</span>,<span class="string">'Symmlq stagnated without apparent convergence.'</span>)
0658         <span class="keyword">otherwise</span>
0659           warning(<span class="string">'GRIDFIT:solver'</span>,[<span class="string">'One of the scalar quantities calculated in'</span>,<span class="keyword">...</span>
0660             <span class="string">' symmlq was too small or too large to continue computing.'</span>])
0661       <span class="keyword">end</span>
0662       
0663     <span class="keyword">case</span> <span class="string">'lsqr'</span>
0664       <span class="comment">% iterative solver - lsqr. No preconditioner here.</span>
0665       tol = abs(max(z)-min(z))*1.e-13;
0666       <span class="keyword">if</span> params.maskflag
0667         <span class="comment">% there is a mask to use</span>
0668         zgrid=nan(ny,nx);
0669         [zgrid(unmasked),flag] = lsqr(A(:,unmasked),rhs,tol,params.maxiter);
0670       <span class="keyword">else</span>
0671         [zgrid,flag] = lsqr(A,rhs,tol,params.maxiter);
0672         zgrid = reshape(zgrid,ny,nx);
0673       <span class="keyword">end</span>
0674       
0675       <span class="comment">% display a warning if convergence problems</span>
0676       <span class="keyword">switch</span> flag
0677         <span class="keyword">case</span> 0
0678           <span class="comment">% no problems with convergence</span>
0679         <span class="keyword">case</span> 1
0680           <span class="comment">% lsqr iterated MAXIT times but did not converge.</span>
0681           warning(<span class="string">'GRIDFIT:solver'</span>,[<span class="string">'Lsqr performed '</span>, <span class="keyword">...</span>
0682             num2str(params.maxiter),<span class="string">' iterations but did not converge.'</span>])
0683         <span class="keyword">case</span> 3
0684           <span class="comment">% lsqr stagnated, successive iterates were the same</span>
0685           warning(<span class="string">'GRIDFIT:solver'</span>,<span class="string">'Lsqr stagnated without apparent convergence.'</span>)
0686         <span class="keyword">case</span> 4
0687           warning(<span class="string">'GRIDFIT:solver'</span>,[<span class="string">'One of the scalar quantities calculated in'</span>,<span class="keyword">...</span>
0688             <span class="string">' LSQR was too small or too large to continue computing.'</span>])
0689       <span class="keyword">end</span>
0690       
0691   <span class="keyword">end</span>  <span class="comment">% switch params.solver</span>
0692   
0693 <span class="keyword">end</span>  <span class="comment">% if params.tilesize...</span>
0694 
0695 <span class="comment">% only generate xgrid and ygrid if requested.</span>
0696 <span class="keyword">if</span> nargout&gt;1
0697   [xgrid,ygrid]=meshgrid(xnodes,ynodes);
0698 <span class="keyword">end</span>
0699 
0700 <span class="comment">% ============================================</span>
0701 <span class="comment">% End of main function - gridfit</span>
0702 <span class="comment">% ============================================</span>
0703 
0704 <span class="comment">% ============================================</span>
0705 <span class="comment">% subfunction - parse_pv_pairs</span>
0706 <span class="comment">% ============================================</span>
0707 <a name="_sub1" href="#_subfunctions" class="code">function params=parse_pv_pairs(params,pv_pairs)</a>
0708 <span class="comment">% parse_pv_pairs: parses sets of property value pairs, allows defaults</span>
0709 <span class="comment">% usage: params=parse_pv_pairs(default_params,pv_pairs)</span>
0710 <span class="comment">%</span>
0711 <span class="comment">% arguments: (input)</span>
0712 <span class="comment">%  default_params - structure, with one field for every potential</span>
0713 <span class="comment">%             property/value pair. Each field will contain the default</span>
0714 <span class="comment">%             value for that property. If no default is supplied for a</span>
0715 <span class="comment">%             given property, then that field must be empty.</span>
0716 <span class="comment">%</span>
0717 <span class="comment">%  pv_array - cell array of property/value pairs.</span>
0718 <span class="comment">%             Case is ignored when comparing properties to the list</span>
0719 <span class="comment">%             of field names. Also, any unambiguous shortening of a</span>
0720 <span class="comment">%             field/property name is allowed.</span>
0721 <span class="comment">%</span>
0722 <span class="comment">% arguments: (output)</span>
0723 <span class="comment">%  params   - parameter struct that reflects any updated property/value</span>
0724 <span class="comment">%             pairs in the pv_array.</span>
0725 <span class="comment">%</span>
0726 <span class="comment">% Example usage:</span>
0727 <span class="comment">% First, set default values for the parameters. Assume we</span>
0728 <span class="comment">% have four parameters that we wish to use optionally in</span>
0729 <span class="comment">% the function examplefun.</span>
0730 <span class="comment">%</span>
0731 <span class="comment">%  - 'viscosity', which will have a default value of 1</span>
0732 <span class="comment">%  - 'volume', which will default to 1</span>
0733 <span class="comment">%  - 'pie' - which will have default value 3.141592653589793</span>
0734 <span class="comment">%  - 'description' - a text field, left empty by default</span>
0735 <span class="comment">%</span>
0736 <span class="comment">% The first argument to examplefun is one which will always be</span>
0737 <span class="comment">% supplied.</span>
0738 <span class="comment">%</span>
0739 <span class="comment">%   function examplefun(dummyarg1,varargin)</span>
0740 <span class="comment">%   params.Viscosity = 1;</span>
0741 <span class="comment">%   params.Volume = 1;</span>
0742 <span class="comment">%   params.Pie = 3.141592653589793</span>
0743 <span class="comment">%</span>
0744 <span class="comment">%   params.Description = '';</span>
0745 <span class="comment">%   params=parse_pv_pairs(params,varargin);</span>
0746 <span class="comment">%   params</span>
0747 <span class="comment">%</span>
0748 <span class="comment">% Use examplefun, overriding the defaults for 'pie', 'viscosity'</span>
0749 <span class="comment">% and 'description'. The 'volume' parameter is left at its default.</span>
0750 <span class="comment">%</span>
0751 <span class="comment">%   examplefun(rand(10),'vis',10,'pie',3,'Description','Hello world')</span>
0752 <span class="comment">%</span>
0753 <span class="comment">% params =</span>
0754 <span class="comment">%     Viscosity: 10</span>
0755 <span class="comment">%        Volume: 1</span>
0756 <span class="comment">%           Pie: 3</span>
0757 <span class="comment">%   Description: 'Hello world'</span>
0758 <span class="comment">%</span>
0759 <span class="comment">% Note that capitalization was ignored, and the property 'viscosity'</span>
0760 <span class="comment">% was truncated as supplied. Also note that the order the pairs were</span>
0761 <span class="comment">% supplied was arbitrary.</span>
0762 
0763 npv = length(pv_pairs);
0764 n = npv/2;
0765 
0766 <span class="keyword">if</span> n~=floor(n)
0767   error <span class="string">'Property/value pairs must come in PAIRS.'</span>
0768 <span class="keyword">end</span>
0769 <span class="keyword">if</span> n&lt;=0
0770   <span class="comment">% just return the defaults</span>
0771   <span class="keyword">return</span>
0772 <span class="keyword">end</span>
0773 
0774 <span class="keyword">if</span> ~isstruct(params)
0775   error <span class="string">'No structure for defaults was supplied'</span>
0776 <span class="keyword">end</span>
0777 
0778 <span class="comment">% there was at least one pv pair. process any supplied</span>
0779 propnames = fieldnames(params);
0780 lpropnames = lower(propnames);
0781 <span class="keyword">for</span> i=1:n
0782   p_i = lower(pv_pairs{2*i-1});
0783   v_i = pv_pairs{2*i};
0784   
0785   ind = strmatch(p_i,lpropnames,<span class="string">'exact'</span>);
0786   <span class="keyword">if</span> isempty(ind)
0787     ind = find(strncmp(p_i,lpropnames,length(p_i)));
0788     <span class="keyword">if</span> isempty(ind)
0789       error([<span class="string">'No matching property found for: '</span>,pv_pairs{2*i-1}])
0790     <span class="keyword">elseif</span> length(ind)&gt;1
0791       error([<span class="string">'Ambiguous property name: '</span>,pv_pairs{2*i-1}])
0792     <span class="keyword">end</span>
0793   <span class="keyword">end</span>
0794   p_i = propnames{ind};
0795   
0796   <span class="comment">% override the corresponding default in params</span>
0797   params = setfield(params,p_i,v_i); <span class="comment">%#ok</span>
0798   
0799 <span class="keyword">end</span>
0800 
0801 
0802 <span class="comment">% ============================================</span>
0803 <span class="comment">% subfunction - check_params</span>
0804 <span class="comment">% ============================================</span>
0805 <a name="_sub2" href="#_subfunctions" class="code">function params = check_params(params)</a>
0806 
0807 <span class="comment">% check the parameters for acceptability</span>
0808 <span class="comment">% smoothness == 1 by default</span>
0809 <span class="keyword">if</span> isempty(params.smoothness)
0810   params.smoothness = 1;
0811 <span class="keyword">else</span>
0812   <span class="keyword">if</span> (numel(params.smoothness)&gt;2) || any(params.smoothness&lt;=0)
0813     error <span class="string">'Smoothness must be scalar (or length 2 vector), real, finite, and positive.'</span>
0814   <span class="keyword">end</span>
0815 <span class="keyword">end</span>
0816 
0817 <span class="comment">% regularizer  - must be one of 4 options - the second and</span>
0818 <span class="comment">% third are actually synonyms.</span>
0819 valid = {<span class="string">'springs'</span>, <span class="string">'diffusion'</span>, <span class="string">'laplacian'</span>, <span class="string">'gradient'</span>};
0820 <span class="keyword">if</span> isempty(params.regularizer)
0821   params.regularizer = <span class="string">'diffusion'</span>;
0822 <span class="keyword">end</span>
0823 ind = find(strncmpi(params.regularizer,valid,length(params.regularizer)));
0824 <span class="keyword">if</span> (length(ind)==1)
0825   params.regularizer = valid{ind};
0826 <span class="keyword">else</span>
0827   error([<span class="string">'Invalid regularization method: '</span>,params.regularizer])
0828 <span class="keyword">end</span>
0829 
0830 <span class="comment">% interp must be one of:</span>
0831 <span class="comment">%    'bilinear', 'nearest', or 'triangle'</span>
0832 <span class="comment">% but accept any shortening thereof.</span>
0833 valid = {<span class="string">'bilinear'</span>, <span class="string">'nearest'</span>, <span class="string">'triangle'</span>};
0834 <span class="keyword">if</span> isempty(params.interp)
0835   params.interp = <span class="string">'triangle'</span>;
0836 <span class="keyword">end</span>
0837 ind = find(strncmpi(params.interp,valid,length(params.interp)));
0838 <span class="keyword">if</span> (length(ind)==1)
0839   params.interp = valid{ind};
0840 <span class="keyword">else</span>
0841   error([<span class="string">'Invalid interpolation method: '</span>,params.interp])
0842 <span class="keyword">end</span>
0843 
0844 <span class="comment">% solver must be one of:</span>
0845 <span class="comment">%    'backslash', '\', 'symmlq', 'lsqr', or 'normal'</span>
0846 <span class="comment">% but accept any shortening thereof.</span>
0847 valid = {<span class="string">'backslash'</span>, <span class="string">'\'</span>, <span class="string">'symmlq'</span>, <span class="string">'lsqr'</span>, <span class="string">'normal'</span>};
0848 <span class="keyword">if</span> isempty(params.solver)
0849   params.solver = <span class="string">'\'</span>;
0850 <span class="keyword">end</span>
0851 ind = find(strncmpi(params.solver,valid,length(params.solver)));
0852 <span class="keyword">if</span> (length(ind)==1)
0853   params.solver = valid{ind};
0854 <span class="keyword">else</span>
0855   error([<span class="string">'Invalid solver option: '</span>,params.solver])
0856 <span class="keyword">end</span>
0857 
0858 <span class="comment">% extend must be one of:</span>
0859 <span class="comment">%    'never', 'warning', 'always'</span>
0860 <span class="comment">% but accept any shortening thereof.</span>
0861 valid = {<span class="string">'never'</span>, <span class="string">'warning'</span>, <span class="string">'always'</span>};
0862 <span class="keyword">if</span> isempty(params.extend)
0863   params.extend = <span class="string">'warning'</span>;
0864 <span class="keyword">end</span>
0865 ind = find(strncmpi(params.extend,valid,length(params.extend)));
0866 <span class="keyword">if</span> (length(ind)==1)
0867   params.extend = valid{ind};
0868 <span class="keyword">else</span>
0869   error([<span class="string">'Invalid extend option: '</span>,params.extend])
0870 <span class="keyword">end</span>
0871 
0872 <span class="comment">% tilesize == inf by default</span>
0873 <span class="keyword">if</span> isempty(params.tilesize)
0874   params.tilesize = inf;
0875 <span class="keyword">elseif</span> (length(params.tilesize)&gt;1) | (params.tilesize&lt;3)
0876   error <span class="string">'Tilesize must be scalar and &gt; 0.'</span>
0877 <span class="keyword">end</span>
0878 
0879 <span class="comment">% overlap == 0.20 by default</span>
0880 <span class="keyword">if</span> isempty(params.overlap)
0881   params.overlap = 0.20;
0882 <span class="keyword">elseif</span> (length(params.overlap)&gt;1) | (params.overlap&lt;0) | (params.overlap&gt;0.5)
0883   error <span class="string">'Overlap must be scalar and 0 &lt; overlap &lt; 1.'</span>
0884 <span class="keyword">end</span>
0885 
0886 <span class="comment">% ============================================</span>
0887 <span class="comment">% subfunction - tiled_gridfit</span>
0888 <span class="comment">% ============================================</span>
0889 <a name="_sub3" href="#_subfunctions" class="code">function zgrid=tiled_gridfit(x,y,z,xnodes,ynodes,params)</a>
0890 <span class="comment">% tiled_gridfit: a tiled version of gridfit, continuous across tile boundaries</span>
0891 <span class="comment">% usage: [zgrid,xgrid,ygrid]=tiled_gridfit(x,y,z,xnodes,ynodes,params)</span>
0892 <span class="comment">%</span>
0893 <span class="comment">% Tiled_gridfit is used when the total grid is far too large</span>
0894 <span class="comment">% to model using a single call to gridfit. While gridfit may take</span>
0895 <span class="comment">% only a second or so to build a 100x100 grid, a 2000x2000 grid</span>
0896 <span class="comment">% will probably not run at all due to memory problems.</span>
0897 <span class="comment">%</span>
0898 <span class="comment">% Tiles in the grid with insufficient data (&lt;4 points) will be</span>
0899 <span class="comment">% filled with NaNs. Avoid use of too small tiles, especially</span>
0900 <span class="comment">% if your data has holes in it that may encompass an entire tile.</span>
0901 <span class="comment">%</span>
0902 <span class="comment">% A mask may also be applied, in which case tiled_gridfit will</span>
0903 <span class="comment">% subdivide the mask into tiles. Note that any boolean mask</span>
0904 <span class="comment">% provided is assumed to be the size of the complete grid.</span>
0905 <span class="comment">%</span>
0906 <span class="comment">% Tiled_gridfit may not be fast on huge grids, but it should run</span>
0907 <span class="comment">% as long as you use a reasonable tilesize. 8-)</span>
0908 
0909 <span class="comment">% Note that we have already verified all parameters in check_params</span>
0910 
0911 <span class="comment">% Matrix elements in a square tile</span>
0912 tilesize = params.tilesize;
0913 <span class="comment">% Size of overlap in terms of matrix elements. Overlaps</span>
0914 <span class="comment">% of purely zero cause problems, so force at least two</span>
0915 <span class="comment">% elements to overlap.</span>
0916 overlap = max(2,floor(tilesize*params.overlap));
0917 
0918 <span class="comment">% reset the tilesize for each particular tile to be inf, so</span>
0919 <span class="comment">% we will never see a recursive call to tiled_gridfit</span>
0920 Tparams = params;
0921 Tparams.tilesize = inf;
0922 
0923 nx = length(xnodes);
0924 ny = length(ynodes);
0925 zgrid = zeros(ny,nx);
0926 
0927 <span class="comment">% linear ramp for the bilinear interpolation</span>
0928 rampfun = inline(<span class="string">'(t-t(1))/(t(end)-t(1))'</span>,<span class="string">'t'</span>);
0929 
0930 <span class="comment">% loop over each tile in the grid</span>
0931 h = waitbar(0,<span class="string">'Relax and have a cup of JAVA. Its my treat.'</span>);
0932 warncount = 0;
0933 xtind = 1:min(nx,tilesize);
0934 <span class="keyword">while</span> ~isempty(xtind) &amp; (xtind(1)&lt;=nx)
0935   
0936   xinterp = ones(1,length(xtind));
0937   <span class="keyword">if</span> (xtind(1) ~= 1)
0938     xinterp(1:overlap) = rampfun(xnodes(xtind(1:overlap)));
0939   <span class="keyword">end</span>
0940   <span class="keyword">if</span> (xtind(end) ~= nx)
0941     xinterp((end-overlap+1):end) = 1-rampfun(xnodes(xtind((end-overlap+1):end)));
0942   <span class="keyword">end</span>
0943   
0944   ytind = 1:min(ny,tilesize);
0945   <span class="keyword">while</span> ~isempty(ytind) &amp; (ytind(1)&lt;=ny)
0946     <span class="comment">% update the waitbar</span>
0947     waitbar((xtind(end)-tilesize)/nx + tilesize*ytind(end)/ny/nx)
0948     
0949     yinterp = ones(length(ytind),1);
0950     <span class="keyword">if</span> (ytind(1) ~= 1)
0951       yinterp(1:overlap) = rampfun(ynodes(ytind(1:overlap)));
0952     <span class="keyword">end</span>
0953     <span class="keyword">if</span> (ytind(end) ~= ny)
0954       yinterp((end-overlap+1):end) = 1-rampfun(ynodes(ytind((end-overlap+1):end)));
0955     <span class="keyword">end</span>
0956     
0957     <span class="comment">% was a mask supplied?</span>
0958     <span class="keyword">if</span> ~isempty(params.mask)
0959       submask = params.mask(ytind,xtind);
0960       Tparams.mask = submask;
0961     <span class="keyword">end</span>
0962     
0963     <span class="comment">% extract data that lies in this grid tile</span>
0964     k = (x&gt;=xnodes(xtind(1))) &amp; (x&lt;=xnodes(xtind(end))) &amp; <span class="keyword">...</span>
0965         (y&gt;=ynodes(ytind(1))) &amp; (y&lt;=ynodes(ytind(end)));
0966     k = find(k);
0967     
0968     <span class="keyword">if</span> length(k)&lt;4
0969       <span class="keyword">if</span> warncount == 0
0970         warning(<span class="string">'GRIDFIT:tiling'</span>,<span class="string">'A tile was too underpopulated to model. Filled with NaNs.'</span>)
0971       <span class="keyword">end</span>
0972       warncount = warncount + 1;
0973       
0974       <span class="comment">% fill this part of the grid with NaNs</span>
0975       zgrid(ytind,xtind) = NaN;
0976       
0977     <span class="keyword">else</span>
0978       <span class="comment">% build this tile</span>
0979       zgtile = <a href="gridfit.html" class="code" title="function [zgrid,xgrid,ygrid] = gridfit(x,y,z,xnodes,ynodes,varargin)">gridfit</a>(x(k),y(k),z(k),xnodes(xtind),ynodes(ytind),Tparams);
0980       
0981       <span class="comment">% bilinear interpolation (using an outer product)</span>
0982       interp_coef = yinterp*xinterp;
0983       
0984       <span class="comment">% accumulate the tile into the complete grid</span>
0985       zgrid(ytind,xtind) = zgrid(ytind,xtind) + zgtile.*interp_coef;
0986       
0987     <span class="keyword">end</span>
0988     
0989     <span class="comment">% step to the next tile in y</span>
0990     <span class="keyword">if</span> ytind(end)&lt;ny
0991       ytind = ytind + tilesize - overlap;
0992       <span class="comment">% are we within overlap elements of the edge of the grid?</span>
0993       <span class="keyword">if</span> (ytind(end)+max(3,overlap))&gt;=ny
0994         <span class="comment">% extend this tile to the edge</span>
0995         ytind = ytind(1):ny;
0996       <span class="keyword">end</span>
0997     <span class="keyword">else</span>
0998       ytind = ny+1;
0999     <span class="keyword">end</span>
1000     
1001   <span class="keyword">end</span> <span class="comment">% while loop over y</span>
1002   
1003   <span class="comment">% step to the next tile in x</span>
1004   <span class="keyword">if</span> xtind(end)&lt;nx
1005     xtind = xtind + tilesize - overlap;
1006     <span class="comment">% are we within overlap elements of the edge of the grid?</span>
1007     <span class="keyword">if</span> (xtind(end)+max(3,overlap))&gt;=nx
1008       <span class="comment">% extend this tile to the edge</span>
1009       xtind = xtind(1):nx;
1010     <span class="keyword">end</span>
1011   <span class="keyword">else</span>
1012     xtind = nx+1;
1013   <span class="keyword">end</span>
1014 
1015 <span class="keyword">end</span> <span class="comment">% while loop over x</span>
1016 
1017 <span class="comment">% close down the waitbar</span>
1018 close(h)
1019 
1020 <span class="keyword">if</span> warncount&gt;0
1021   warning(<span class="string">'GRIDFIT:tiling'</span>,[num2str(warncount),<span class="string">' tiles were underpopulated &amp; filled with NaNs'</span>])
1022 <span class="keyword">end</span>
1023 
1024 
1025</pre></div>
<hr><address>Generated on Sat 09-Feb-2013 12:20:36 by <strong>B.&nbsp;Gustavsson</strong> with <strong><a href="http://www.artefact.tk/software/matlab/m2html/" target="_parent">m2html</a></strong> &copy; 2003</address>
</body>
</html>